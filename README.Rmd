---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

  <!-- badges: start -->
  [![R build status](https://github.com/sofpn/rprimer/workflows/R-CMD-check/badge.svg)](https://github.com/sofpn/rprimer/actions)
  <!-- badges: end -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

### Package overview 

rprimer provides functions for designing (RT)-(q/dd)PCR assays from multiple DNA sequence alignments. In essence, the design process is built on three functions: 

* `getConsensusProfile()`
* `getOligos()`
* `getAssays()`

In this document, I demonstrate how to use rprimer by designing an RT-(q/d)PCR assay for detection of hepatitis E virus, which is a highly variable RNA virus. 

### Installation

You can install rprimer from [GitHub](https://github.com/) with:

  ``` r
# install.packages("devtools")
devtools::install_github("sofpn/rprimer")
```
Initial setup for the code in this document: 

``` {r, message=FALSE, warn=FALSE}
# library(rprimer)
devtools::load_all(".")
library(magrittr) ## Required for the pipe operator 
library(tibble)
library(Biostrings) ## Required to import alignments 
```
### To start

The first step is to import an alignment with target sequences of interest and, if preferred, mask positions with high gap frequency. `readDNAMultipleAlignment()` and `maskGaps()` from Biostrings can be used for this part. 

The file "example_alignment.txt" is provided and contains 100 hepatitis E virus sequences. 

```{r}
infile <- system.file('extdata', 'example_alignment.txt', package = 'rprimer')

myAlignment <- infile %>%
  Biostrings::readDNAMultipleAlignment(., format = "fasta") %>%
  Biostrings::maskGaps(., min.fraction = 0.5, min.block.width = 1) ## Mask positions with at least 50 % gaps 
```

### Step 1: `getConsensusProfile` 

`getConsensusProfile()` takes a `Biostrings::DNAMultipleAlignment` object as input and returns an `RprimerProfile` object, which contains all the information needed for the subsequent design process. 

```{r}
 myConsensusProfile <- getConsensusProfile(myAlignment, iupacThreshold = 0.05)
```

The output can be coerced to a tibble or data frame: 

```{r}
tibble::as_tibble(myConsensusProfile)
```
Some comments on the data: 

* Majority refers to the majority consensus sequence, which is the most frequently occurring base, and identity is the proportion of that base in the alignment. 

* The IUPAC consensus sequence includes wobble bases according to the IUPAC-nomenclature. All nucleotides with a frequency higher than the `iupacThreshold` will be taken into account in the IUPAC consensus sequence. 

* Entropy refers to Shannon entropy, which is a measurement of variability. A value of zero indicate no variability and a high value indicate high variability.

The data can be visualized with `plotData()`, and specific regions can be highlighted using the optional arguments `shadeFrom` and `shadeTo`, e.g: 

```{r}
plotData(myConsensusProfile, shadeFrom = 500, shadeTo = 1000)
```

It is also possible to inspect the nucleotide distribution with `plotNucleotides()`. `from` and `to` indicates the plotting range (positions), and `rc` regulates whether the sequence should be displayed as a reverse complement or not. 

```{r, fig.align="center", fig.width=6, fig.height=4}
## Plot the first 30 bases 
plotNucleotides(myConsensusProfile, from = 1, to = 30, rc = FALSE) 
```

### Step 2: `getOligos`

`getOligos()` searches for oligos from the following constraints: 

* `maxGapFrequency` Maximum gap frequency, defaults to `0.1`. 
* `length` Oligo length, defaults to `18:22`.
* `maxDegeneracy` Maximum number of degenerate variants of each oligo, defaults to `4`. 
* `gcClamp` If oligos must have a GC-clamp (recommended for primers), defaults to `TRUE`. 
* `avoid3endRuns` If oligos with more than two runs of the same nucleotide at the terminal 3' end should be avodied (recommended for primers), defaults to `TRUE`.
* `avoid5endG` If oligos with a G at the terminal 5' end should be avoided (recommended for probes), defaults to `FALSE`.
* `minEndIdentity` Optional. Minimum allowed identity at the 3' end (i.e. the last five bases). E.g., if set to `1`, only oligos with complete target conservation at the 3' end will be considered.
* `gcRange` GC-content-range, defaults to `c(0.45, 0.55)`.
* `tmRange` Melting temperature (Tm) range, defaults to `c(50, 65)`. Tm is calculated using the nearest-neighbor method. See `?rprimer::getOligos` for a detailed description and references.
* `concOligo` Oligo concentration (for Tm calculation), defaults to `5e-07` M (500 nM)
* `concNa` Sodium ion concentration (for Tm calculation), defaults to `0.05` M (50 mM).
* `showAllVariants` If sequence, GC-content and Tm should be presented for all variants of each oligo (in case of degenerate bases).`TRUE` (slower) or `FALSE` (faster), defaults to `TRUE`. 

In addition, `get_oligos()` avoids:

* Majority oligos with more than than three consecutive runs of the same dinucleotide (e.g. "TATATATA")
* Majority oligos with more than four consecutive runs of the same nucleotide  (e.g. "AAAAA")
* Majority oligos that are duplicated (to prevent binding at several places on the genome)

An error message will return if no oligos are found. 

Below, I design both primers and probes. I use somewhat different settings for the two oligo types.

``` {r}
myPrimers <- getOligos(myConsensusProfile,
                       length = 18:22,
                       maxGapFrequency = 0.05,
                       maxDegeneracy = 4,
                       gcClamp = TRUE,
                       avoid3EndRuns = TRUE,
                       avoid5EndG = FALSE,
                       minEndIdentity = 0.99,
                       gcRange = c(0.40, 0.60),
                       tmRange = c(50, 65),
                       showAllVariants = TRUE)

myProbes <- getOligos(myConsensusProfile,
                      length = 16:22,
                      maxGapFrequency = 0.05,
                      maxDegeneracy = 4,
                      gcClamp = FALSE,
                      avoid3EndRuns = FALSE,
                      avoid5EndG = TRUE,
                      minEndIdentity = NULL,
                      gcRange = c(0.40, 0.60),
                      tmRange = c(50, 75),
                      showAllVariants = TRUE)
```

### Step 4: `getAssays`

`getAssays()` finds pairs of forward and reverse primers and combines them with probes (optional). 

Assays are designed from the following constraints: 

* `length` Amplicon length, defaults to `65:120`.
* `maxTmDifferencePrimers` Maximum Tm difference between the two primers (absolute value, calculated for majority primers), defaults to `2`.
* `tmDifferencePrimersProbe` Acceptable Tm difference between the primers (average Tm of the primer pair) and probe, defaults to `c(0, 20)`. The Tm-difference is calculated by subtracting the Tm of the probe with the average Tm of the (majority) primer pair. Thus, a negative Tm-difference means that the Tm of the probe is lower than the average Tm of the primer pair.

An error message will return if no assays are found.

```{r}
myAssays <- getAssays(primers = myPrimers, 
                      probes = myProbes,
                      length = 65:100,
                      maxTmDifferencePrimers = 1.5,
                      tmDifferencePrimersProbe = c(0, 10))
```

### Session info 

```{r}
sessionInfo()
```

