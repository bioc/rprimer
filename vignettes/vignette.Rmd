---
title: "rprimer"
author: "Sofia Persson"
package: rprimer
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Getting started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

Primer and probe design are central parts of PCR assay development. Successful amplification and detection depend on several factors, such as optimal primer and probe length, GC-content, melting temperature and sequence complexity. Primer and probes must be designed so that formation of dimers and hairpin loops are avoided, and the intended target region must be sufficiently conserved to avoid severe mismatches between the primers/probe and the template. This together makes PCR assay design a challenging task, which is not least reflected by the large number of computational methods available. One of the most comprehensive and widely used tools is Primer3. However, one important limitation with Primer3 is that the design process is based on a single sequence, which means that primers can be inadvertently placed in sequence heterogeneous regions, resulting in quantification bias and poor coverage of the target sequences of interest (low inclusivity). This can, in part, be circumvented by making a “consensus profile” from an alignment of the target sequences of interest, and masking the variable regions before the design process. However, for many applications, it can be difficult to find even a few completely conserved regions suitable as primer or probe targets. A design strategy that can tolerate some degree of genetic variation is therefore warranted.

A common approach for amplifying sequence diverse targets is to use degenerate primers and probes. A degenerate primer has one or more positions with several possible bases, and the degeneracy refers to the number of unique sequence variants it encompasses. These ambiguous bases are named according to a coding system determined by IUPAC. For instance, the ambiguous base K can be either G or T, and N can be A, C, G or T. For some applications, it is not uncommon to see highly degenerate primers with up to several hundreds of sequence variants. However, as the number of sequence variants rises, the likelihood of interaction with non-targets or other primer variants also increases, which risks to reduce both the sensitivity and specificity of the assay. The most optimal design strategy would therefore be to find primers and probes with as low degeneracy as possible, without compromising with inclusivity. 

PCR based methods are a keystone for diagnosis of viral diseases and for the surveillance of pathogenic viruses in food and the environment. Här stalls stora KRAV PÅ DIAGNOSTISK ASSAY
-	I visa fall är det viktigt att kvantifiera viral load, vilket innebär att man inte har ”råd” med mismatcher som kan skapa kvantifieringsbias 
-	Att dela upp en virusart på flera olika assayer är kostsamt och tidskrävande, och ofta finns begränsat med patientprov 
-	Ofta vill man inte nesta pga tidsåtgång och kontaminationsrisk
-	Måste kontinuerligt övervaka 

RNA viruses have high mutational rates due to the lack of proofreading activity of their RNA dependent RNA polymerase. This, in combination with short generation times, gives potential for high genetic diversity, on which natural selection can occur. Some viral species display quite remarkable sequence variability and evolve quickly. However, even the most variable virus species have few short, highly conserved gene segments or non-coding regions essential for e.g., replication, transcription and assembly. These regions are particularly useful as targets for diagnostic assays, since they are not expected to change over time.
There are several tools available for design of degenerate primers and probes. Some are based on multiple alignments and some are “greedy” , och flera av dem är specifikt utvecklade till ett visst forskningsområde. Gene fisher, primer hunter, openprimer. Kolla reviewen.

This R package was especially developed to meet the specific needs of viral diagnostics and detection. 
2) to evaluate ALL sequence variants of degenerate oligos 3) to provide a graphical overview of sequence conservation, both in overview and detail 4) to provide something in R, a simple workflow, with a data frame format, with no external dependencies, which is nowadays a widely used language among biologists 4) have the possibility of designing conserved 3’ ends to “anchor”.. since mismatches at the 3’ end can significantly reduce amplification efficiency. 


In this document, I demonstrate how to use rprimer by searching for RT-q/dPCR assay candidates for detection of hepatitis E virus.

# Installation

rprimer can be installed from [GitHub](https://github.com/) with:

``` r
if (!requireNamespace("devtools", quietly = TRUE))
    install.packages("devtools")
devtools::install_github("sofpn/rprimer")
```
```{r, internal setup, echo=FALSE, warning=FALSE, message=FALSE}
library(kableExtra)
#devtools::load_all(".")
```
```{r setup, message = FALSE, warning = FALSE}
library(rprimer)
```

# Design process 

The oligo design process can be divided in four steps. The first step is to ...

The second step is to remove all oligos with a degeneracy higher than the user specified threshold (the maximum degeneracy of primers and probes), and 

The third step is to generate all sequence variants of each oligo, and to collect information... 

The fourth step is to 

Sequences with low complexity will not be considered as primers and probes. This includes sequences with more than than three consecutive runs of
the same di-nucleotide (e.g. "TATATATA") and/or With more than four consecutive runs of the same nucleotide  (e.g. "AAAAA").

Step 1: Generate all possible oligos 
For a specific primer length i: 
The first step is to generate a matrix with all possible oligos of length i from the vector that holds the IUPAC consensus sequence in the `RprimerProfile` object. Hence, the matrix will have i columns and length(x) - 1 rows. The second step, is to calculate the degeneracy (number of unique sequence variants) of all oligo candidates, and to exclude all oligos with a degeeracy higher than the maximum stated degeneracy of primers and probes, which, for a sequence variable target, will be quite a lot of exclusions.. 

It finds all possible oligos of a specific length from an
\code{RprimerProfile} object, and returns a list containing
start and end position,
length, IUPAC sequence (the oligo DNA sequence with wobble bases), degeneracy
(number of variants of each oligo), maximum gap frequency,
mean overall identity, and minimum 3'-end identity at
both forward and reverse direction (the 3'-end is here seen as the last five
bases of the oligo).

Step 2: Filter oligos 
is the second step of the oligo-design process. It
removes oligos with gap frequency and degeneracy above the specified
thresholds.

Step 3: Calculate info on all variants
is the third step of the oligo-design process.
It returns all sequence variants of each oligo, both in sense and anti-sense
(reverse complement) direction. For each sequence variant, information is
provided on GC-content, melting temperature,
and the presence of a GC-clamp (good for primers),
terminal 3'-end runs (bad for primers), mono- and di-nucleotide repeats
(bad for primers and probes) and terminal five end G:s (bad for probes)

## Limitations 

rprimer covers a lot of important steps in the oligo and assay design processes, but not all. Two very important, additional steps are 1) checks for the potential of primer-dimer and hairpin formation and 2) in silico checks for exclusivity, by matching the primer and probe set to off-targets.

A suggested workflow for primer, probe and assay design is presented below. 
Align full length sequences 
recommended to check inclusivity 

## "Big picture"
[flowchart]

# Functions 

The workflow is built on three functions: 

* `consensusProfile()`
* `oligos()`  
* `assays()` 

And a plotting function, `plotData()`, for visualization.

# Workflow

## Import alignment 

The first step is to import an alignment with the target sequences of interest. `readDNAMultipleAlignment()` from Biostrings (Pagès et al., 2020) do the work for this part. The input file can contain up to several thousands of sequences. 

The file "example_alignment.txt" is provided with the package and contains 100 hepatitis E virus sequences.  

It is possible to mask positions with high gap frequency by using `Biostrings::maskGaps()`, but this should be done with caution since it may lead to placement of oligos and amplicons in insert-rich regions. However, in my example, I have applied a gap mask to get the alignment to agree more with the average hepatitis E virus genome length. In case a gap mask is used, a good idea could be to verify the design process without gap mask as well.

```{r}
infile <- system.file('extdata', 'example_alignment.txt', package = 'rprimer')

myAlignment <- Biostrings::readDNAMultipleAlignment(infile, format = "fasta")
myAlignment <- Biostrings::maskGaps(myAlignment, 
                                    min.fraction = 0.5, 
                                    min.block.width = 1) 
```

## Step 1: `consensusProfile` 

`consensusProfile()` takes a `Biostrings::DNAMultipleAlignment` object as input and returns an `RprimerProfile`-object, which contains all the information needed for the subsequent design process. Masked positions are excluded.

```{r}
myConsensusProfile <- consensusProfile(myAlignment, iupacThreshold = 0.05)
```

Results (first ten rows):

```{r, echo=FALSE}
myConsensusProfile[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

Some comments on the data: 

* Majority refers to the majority consensus sequence, which is the most frequently occurring base
* Identity is the proportion of the most frequently occurring base when gaps and other bases than A, C, G and T are not taken into account
* IUPAC refers to the ambiguous base according to the IUPAC coding system. It includes all DNA bases (A, C, G, T) that occurs with a frequency higher than the stated `iupacThreshold` at each position 
* Entropy refers to Shannon entropy, which is a measurement of variability. A value of zero indicate no variability and a high value indicate high variability. Gaps and other bases than A, C, G and T are not included in this calculation 

The results can be visualized with `plotData()`. You can either plot the entire genome to get an overview:

```{r, fig.width=12, fig.height=6}
plotData(myConsensusProfile)
```
(The dots represent the value at each position and the black lines represent centered running averages)

Or zoom into a specific region of interest for a more detailed picture:

```{r, fig.width=12, fig.height=6}
myRoi <- myConsensusProfile[
  myConsensusProfile$position >= 5000 & myConsensusProfile$position <= 5050, 
  ]

plotData(myRoi)
```

It is also possible to plot the nucleotide distribution, by specifying `type = nucleotide`: 

```{r, fig.width=6, fig.height=6}
plotData(myRoi, type = "nucleotide")
```

## Step 2: `oligos`

`oligos()` searches for primers and probes (if selected) from an `RprimerProfile`-object, and returns an `RprimerOligo` object. 

The following settings can be used: 

* `maxGapFrequency` Maximum gap frequency in the target alignment for primer and probe binding regions, defaults to `0.05`
* `lengthPrimer` Primer length, defaults to `18:22`
* `maxDegeneracyPrimer` Maximum number of sequence variants of each primer, defaults to `4`
* `gcClampPrimer` If primers must have a GC-clamp, defaults to `TRUE`. A GC-clamp is identified as two to three G or C:s within the last five bases (3'-end) of the primer
* `avoidThreeendRunsPrimer` If primers with more than two runs of the same nucleotide at the terminal 3'-end should be avoided, defaults to `TRUE`
* `minEndIdentityPrimer` Minimum allowed identity at the 3'-end (the last five bases). E.g., if set to `1`, only primers with complete target conservation at the 3' end will be considered. Defaults to `0` 
* `gcRangePrimer` GC-content-range for primers, defaults to `c(0.40, 0.60)`
* `tmRangePrimer` Melting temperature range of primers, defaults to `c(55, 65)` 
* `concPrimer` Primer concentration in nM (for Tm calculation), defaults to `500`
* `probe` If probes should be designed as well, defaults to `TRUE`
* `lengthProbe` Probe length, defaults to `18:22`
* `maxDegeneracyProbe` Maximum number of variants of each probe, defaults to `4`
* `avoidFiveEndGProbe` If probes with a G at the terminal 5' end should be avoided, defaults to `TRUE` 
* `gcRangeProbe` GC-content-range for probes, defaults to `c(0.40, 0.50)`
* `tmRangeProbe` Melting temperature range of probes, defaults to `c(55, 65)`
* `concProbe` Probe concentration in nM (for Tm calculation), defaults to `250`
* `concNa` Sodium ion concentration in the PCR reaction (for Tm calculation), defaults to `0.05` M (50 mM)

Below, I design both primers and probes using default settings. 

``` {r}
myOligos <- oligos(myConsensusProfile)
```

Results (first ten rows):

```{r, echo=FALSE}
myOligos[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

Some comments on the data: 

* type indicates whether the oligo is a primer or probe candidate 
* fwd indicates whether the oligo is valid in forward direction 
* rev indicates whether the oligo is valid in reverse direction 
* degeneracy tells how many variants there are of that particular oligo. An oligo without any wobble bases will have a value of 1
* identity shows the average identity within the oligo binding region. An identity score of 1 indicates a conserved binding region  


* the oligo is shown in both IUPAC format (with wobble bases) and as all sequence variants 
```{r}
myOligos$iupacSequence[1] # The IUPAC sequence of the first oligo 
myOligos$sequence[[1]] # All sequence variants of the first oligo 
```

* gc give the GC-content and melting temperature of all sequence variants: 
```{r}
myOligos$gcContent[[1]] # GC content of all variants of the first oligo 
myOligos$tm[[1]] # Tm of all variants of the first oligo 
```

All primer and probe candidates can be visualized using `plotData()`:

```{r, fig.align="center", fig.width=12, fig.height=8}
plotData(myOligos)
```

The upper plot shows the binding sites of the primers and probes (some are overlapped), and the lower plots show how the features of the primer and probe candidates are distributed. 

If I want to filter within my results, I can subset using R's standard functionality: #############

```{r}
## Select 
myOligoSubset <- myOligos[]
```

It is, of course, also possible to customize the design process. Below, I design primers with low degeneracy and completely conserved 3'-end binding sites. 

``` {r}
myOligos2 <- oligos(myConsensusProfile, 
                    maxDegeneracyPrimer = 2, 
                    minEndIdentityPrimer = 1, 
                    probe = FALSE)
```

Now, only the most conserved regions will come up as primer binding sites: 

```{r, fig.align="center", fig.width=12, fig.height=8}
plotData(myOligos2)
```

It is also possible to design oligos within a specific region of interest, by subsetting the `RprimerProfile` object:  

``` {r}
myRoi <- myConsensusProfile[myConsensusProfile$position >= 5000 & myConsensusProfile$position <= 6000, ]
myOligos3 <- oligos(myRoi)
```

```{r, fig.align="center", fig.width=12, fig.height=8}
plotData(myOligos3)
```

An error message will return if no oligos are found. If so, a good idea could be to re-run the process from Step 1 and increase the `iupacThreshold` in `consensusProfile()` and/or relax the design constraints in `oligos()`.

## Step 3: `assays`

`assays()` finds pairs of forward and reverse primers within an `RprimerOligo`-object, and combines them with probes, if available. It returns an `RprimerAssay`-object.   

The design process is based on the following criteria:

* `lengthRange` Amplicon length range, defaults to `c(65, 120)`
* `maxTmDiffPrimers` Maximum Tm difference between the two primers (absolute value, calculated for majority primers), defaults to `2`
* `tmDiffPrimersProbe` Acceptable Tm difference between the primers (average Tm of the primer pair) and probe, defaults to `c(0, 20)`. The Tm-difference is calculated by subtracting the Tm of the (majority) probe with the average Tm of the (majority) primer pair. Hence, a negative Tm-difference means that the Tm of the probe is lower than the average Tm of the primer pair

```{r}
myAssays <- assays(myOligos)
```

Output (first ten rows): 

```{r, echo=FALSE}
myAssays[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The output contains many columns, so the most sensible way of inspecting it is probably to use `View(as.data.frame(myAssays))`, if you are using RStudio. 

Some comments on the output: 

* Total degeneracy denotes the total number of oligos in the assay. If no wobble bases are present in primers or probes, the total degeneracy would be 3 

Again, the output can be visualized using `plotData()`: 

```{r, fig.width=12, fig.height=6}
plotData(myAssays)
```

I notice that all assays are located in the conserved region between position 5000-5500. 

The assay candidates can be sorted based on e.g. total degeneracy score: 

```{r}
myAssays <- myAssays[order(myAssays$totalDegeneracy), ]
```

It is also possible to extract assays that fulfill specific criteria, for instance, assays with a total degeneracy below 6:

```{r}
mySelectedAssays <- myAssays[myAssays$totalDegeneracy < 6, ]
```

It is also possible to create a subset of the OLIGO data before the assay design process, if ############################

An error message will return if no assays are found.

## Further handling of the data 

The oligo and assay region(s) can be inspected further by using the `RprimerProfile` object. As an example, I select to take a closer look at the first assay in `myAssays`: 

```{r}

## Find start and end positions for the first assay 
from <- myAssays[1, ]$start
to <- myAssays[1, ]$end

## Subset the RprimerProfile object based on these positions
selection <- myConsensusProfile[myConsensusProfile$position >= from & myConsensusProfile$position <= to, ] 
```

```{r, fig.width=12, fig.height=6}
plotData(selection)
plotData(selection, type = "nucleotide")
```

The consensus amplicon sequence can be obtained by: 

```{r}
paste(selection$iupac, collapse = "")
```

It is also possible to highlight a specific region, using the optional argument `highlight`.

```{r fig 3, fig.width=12, fig.height=6}
plotData(myConsensusProfile, highlight = c(from, to))
```

## Save results to file  

The results can be saved to .txt or .csv-files, for instance: 

```r
write.csv(myAssays, file = "myAssays.csv", quote = FALSE, row.names = FALSE) 
write.table(myAssays, file = "myAssays.txt", quote = FALSE, row.names = FALSE) 
```

## Summary 

The design process is summarized below. In this case, I use default settings for oligo and assay design. 

```r
## Enter the filepath to the alignment 
filepath <- system.file('extdata', 'example_alignment.txt', package = 'rprimer')

## Import alignment 
myAlignment <- Biostrings::readDNAMultipleAlignment(filepath, format = "fasta") 
myAlignment <- Biostrings::maskGaps(myAlignment, min.fraction = 0.5, min.block.width = 1)

## Design primers, probes and assays
myConsensusProfile <- consensusProfile(myAlignment, iupacThreshold = 0.05)
myOligos <- oligos(myConsensusProfile)
myAssays <- assays(myOligos)

```

# Data structures 

The `Rprimer`-classes are extensions of the `DataFrame` class from S4Vectors (Pagès et al., 2020), and behave in a similar way as traditional data frames, with methods for `[`, `$`, `nrow`, `ncol`, `head`, `tail`, etc. They can be coerced to traditional data frames by using `as.data.frame()`. 

Example data sets of each class are provided with the package, and are loaded by: 

```{r, warning=FALSE}
data("exampleRprimerProfile")
data("exampleRprimerOligo")
data("exampleRprimerAssay")
```

To provide reproducible examples, I've also included an alignment of class `Biostrings::MultipleDNAAlignment` (Pagès et al., 2020). It is loaded by `data("exampleRprimerAlignment")`.

# Session info 

```{r}
sessionInfo()
```

# References 

Allawi, H. & SantaLucia, J. (1997) Thermodynamics and NMR of Internal G-T Mismatches in DNA. Biochemistry, 36, 34: 1058-110594

Pagès, H., Aboyoun, P., Gentleman, R., & DebRoy, S. (2020). Biostrings: Efficient manipulation of biological strings. R package version 2.57.2

Pagès, H., Lawrence M., & Aboyoun, P. (2020). S4Vectors: Foundation of vector-like and list-like containers in Bioconductor. R package version 0.27.12

SantaLucia, J., Hatim, T., Allawi H., & Seneviratne, A. (1996) Improved Nearest-Neighbor Parameters for Predicting DNA Duplex Stability. Biochemistry, 35: 3555-3562

SantaLucia, J. (1998) A unified view of polymer, dumbell, and oligonucleotide DNA nearest-neighbor thermodynamics. Proc. Natl. Acad. Sci. USA, 95: 1460-1465
