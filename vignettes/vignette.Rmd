---
title: "rprimer"
author: "Sofia"
package: rprimer
output: BiocStyle::html_document
bibliography: bibliography.bibtex
vignette: >
  %\VignetteIndexEntry{Getting started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

Reverse transcription (RT) PCR based methods are important cornerstones of both clinical diagnosis and environmental surveillance of viruses. Successful RT-PCR analysis depends on several factors, but oligo (primer and probe) design is arguably the most critical part of assay development [@Bustin]. Poorly designed primers may reduce the efficiency of the RT or PCR and poorly designed probes may not hybridize properly with the target, which can result in underestimation of the target concentration or false-negative results. A well-designed oligo binds exclusively to a conserved region of the target of interest and does not fold or form stable interactions (primer dimers) with other oligos. Because many viruses display high sequence variability, it is often difficult to find even a few completely conserved regions that are suitable as primer or probe binding targets. This means that sequence variation must be taken into account in the design process.

A common approach for amplifying sequence diverse targets is to use degenerate primers. A degenerate primer has one or more positions with several possible bases, and the degeneracy refers to the number of unique sequence variants it encompasses. These ambiguous bases are specified by a code system determined by IUPAC. For instance, the IUPAC consensus character K can be either G or T, and N can be A, C, G or T. For many applications, is not uncommon to use primers with up to several hundreds or thousands of sequence variants. However, as the degeneracy increases, the fraction of primers that match perfectly to the target sequence and the synthesized products decreases, which risks to reduce the amplification efficiency (Rose, Henikoff, and Henikoff 2003). An optimal design strategy would therefore be to find primer/primer binding regions with low degeneracy, without compromising the inclusivity [the ability for the assay to amplify all target sequence variants of interest (Hedman et al. 2018)]. 

rprimer seeks to address the challenge of amplifying sequence diverse targets by providing tools to visualize sequence conservation and generate degenerate primer and probe candidates from a multiple sequence alignment. In this document, I demonstrate how to use the package by designing broadly-reactive RT-(q/d)PCR primers, probes and assays for detection of hepatitis E virus (HEV), which is a sequence variable RNA-virus and a common foodborne pathogen.  

# Installation

rprimer can be installed from [GitHub](https://github.com/) with:

``` r
if (!requireNamespace("devtools", quietly = TRUE))
    install.packages("devtools")
devtools::install_github("sofpn/rprimer", auth_token = "85946c568a9f7f71285067bf58d28f25847ecbe0")
```
```{r, internal setup, echo=FALSE, warning=FALSE, message=FALSE}
library(kableExtra)
#devtools::load_all(".")
```
```{r setup, message=FALSE, warning=FALSE}
library(rprimer)
```

# Overview

The package contains four functions:

* `consensusProfile()`
* `oligos()`  
* `assays()` 
* `plotData()`

# Workflow

## Collection of target sequences and multiple alignment 

The first step is to identify and align target sequences of interest. The file “example_alignment.txt” contains an alignment of 200 HEV sequences. The filepath can be retrieved by:  

```r
system.file("extdata", "example_alignment.txt", package = "rprimer")
```

These sequences were collected by searching for “[a-z]”[porgn:__txid1678143] (the taxid of Ortohepevirus A, i.e., HEV) on the nucleotide database of NCBI GenBank, and filtering for sequence lengths > 6000, to retrieve complete and nearly complete genomes. The search had 674 hits (as of January 19, 2021). The sequences were downloaded (as complete record, fasta-file) and run through Hepatitis E virus genotyping tool version 0.1 (https://www.rivm.nl/mpf/typingtool/hev/, accessed January 19, 2021) to verify that they were correctly classified as Ortohepevirus A. Sequences that were not classified as Ortohepevirus A were removed, and the remaining ones (n = 642) were reduced to 200 by random selection, to not provide a too large example dataset for the package. The sequences were then aligned using the online version of mafft version 7 (https://mafft.cbrc.jp/alignment/server/, accessed January 19, 2021), using Auto settings.

## Data import 

Before the design process can begin, the alignment must be imported to R using the `readDNAMultipleAlignment()` function from Biostrings [@PagesBios]. The input file can contain from one up to several thousands of sequences.

For example:

```{r}
infile <- system.file("extdata", "example_alignment.txt", package = "rprimer")

myAlignment <- Biostrings::readDNAMultipleAlignment(infile, format = "fasta")
```

For brevity's sake, and to get the alignment to agree more with the average HEV genome length, I masked all positions with a gap frequency of more than 50 %:   

```{r}
myAlignment <- Biostrings::maskGaps(myAlignment, 
                                    min.fraction = 0.5, 
                                    min.block.width = 1) 
```

However, this should be done with caution, since it may lead to placement of primers and probes in insert-rich regions. This can be checked by verifying the design process without gap mask. 

## Design process

### Step 1: `consensusProfile` 

Once the alignment is imported, the first step is to generate a consensus profile. At each position in the alignment, the following information is retrieved:

* The proportion of the bases A, C, G, T, and “other” 
* The proportion of gaps (-)
* Majority consensus base, which is the most frequently occurring base
* Identity, which is the proportion of the majority consensus base when gaps and ambiguous bases ("other") are excluded
* IUPAC consensus character (ambiguous base). The user can specify an “ambiguity threshold” between 0 and 0.2, and bases with a relative frequency higher than that will be included in the consensus character. A threshold of 0 (default) will catch all the variation, but with the potential cost of generating oligos with high degeneracy. A higher threshold will catch most of the variation, but with the potential cost of missing minor sequence variations (this information is provided by the coverage, see below)
* Shannon entropy, which is a measurement of variability [@shannon1951prediction]. A value of zero indicate complete conservation, and a high value indicate high variability. Gaps and ambiguous bases ("other") are not included in this calculation
* Coverage, which describes the total proportion of bases that are "covered" by the IUPAC consensus character. Gaps and ambiguous bases ("other") are not included in this calculation

Below, I make a consensus profile with an ambiguity threshold of 5 %:

```{r}
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
```

Results (first ten rows):

```{r, echo=FALSE}
myConsensusProfile[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The results can be visualized with `plotData()`. 

```{r, fig.width=12, fig.height=6}
plotData(myConsensusProfile)
```

The dots represent the value at each position and the black lines represent centered running averages. High identity and low entropy values indicate high sequence conservation.

It is also possible to zoom into a specific region of interest:

```{r, fig.width=12, fig.height=6}
selection <- myConsensusProfile[
  myConsensusProfile$position >= 1000 & myConsensusProfile$position <= 1500, 
  ]

plotData(selection)
```

The nucleotide distribution can also be visualized, preferably on a short range (~1-50 bases), by specifying `type = nucleotide`: 

```{r, fig.width=12, fig.height=6}
ntSelection <- myConsensusProfile[
  myConsensusProfile$position >= 1000 & myConsensusProfile$position <= 1020, 
  ]

plotData(ntSelection, type = "nucleotide")
```

### Step 2: `oligos`

The next step is to design oligos. Primers must be designed and probes are optional. Primers can be generated by using either one of two strategies:

* The **ambiguous strategy** (default) generates primers from the IUPAC consensus sequence, meaning that degenerate bases can occur at any position in the oligo

* The **mixed strategy** is based on the Consensus-Degenerate Hybrid Oligonucleotide Primer (CODEHOP) principle [@Rose2]. This approach is recommended for highly variable targets. Here, primers are generated from both the majority and the IUPAC consensus sequence, and consist of a shorter degenerate part at the 3' end (~1/3 of the primer, targeting a conserved region), and a longer consensus part at the 5' end (~2/3 of the primer), which instead of having ambiguous bases contains the most probable nucleotide at each position. The idea is that the degenerate 3' end part will bind specifically to the target sequence in the initial PCR cycles [@Rose2], and promote amplification in spite of eventual mismatches at the 5' consensus part (since mismatches at the 5' end are generally less detrimental than 3' end mismatches). The generated products will match the 5' ends of all primers perfectly, which will allow for efficient amplification of the products in later PCR cycles. To provide a sufficiently high tm in spite of mismatches, it is recommended to design relatively long primers (> 25 bases) when using this strategy  

Probes are always designed using the ambiguous strategy. 

**Design settings**

The arguments of `oligos()` are:

* `x`: the consensus profile from Step 1
* `maxGapFrequency`: maximum gap frequency (in the alignment) for primers and probes, defaults to `0.05`
* `lengthPrimer`: primer length, defaults to `18:22`
* `maxDegeneracyPrimer`: maximum degeneracy for primers, defaults to `4`
* `gcClampPrimer`: if primers should have a GC clamp, defaults to `TRUE`'. A GC clamp is here defined as the presence of two to three G or C:s within the last five bases (3' end) of the oligo. A GC clamp helps to promote specific binding of the 3' end
* `avoidThreeEndRunsPrimer`: if primers with more than two runs of the same nucleotide at the terminal 3' end should be avoided (to reduce the risk of mispriming), defaults to `TRUE`
* `minThreeEndCoveragePrimer`: minimum allowed coverage at the 3' end (the last five bases). If set to `1`, all bases of the 3' end must cover all sequence variants in the target alignment. Defaults to `0.98` 
* `gcRangePrimer`: GC-content range of primers (proportion), defaults to `c(0.40, 0.65)`
* `tmRangePrimer`: melting temperature range for primers, defaults to `c(55, 65)`. Melting temperature is calculated for perfectly matching oligo-target duplexes using the nearest neighbor method [@SantaLuciaUnified], using formula, salt correction method and table values as described in [@santalucia2004thermodynamics]
* `concPrimer`: primer concentration in nM (for tm calculation), defaults to `500`
* `designStrategyPrimer`: design strategy for primers, `"ambiguous"` or `"mixed"`, defaults to `"ambiguous"`  
* `probe`: if probes should be designed as well, defaults to `TRUE`
* `lengthProbe`: defaults to `18:22`
* `maxDegeneracyProbe`: defaults to `4`
* `avoidFiveEndGProbe`: if hydrolysis probes with a G at the terminal 5' end should be avoided (to prevent quenching of the 5' flourophore), defaults to `TRUE` 
* `gcRangeProbe`: defaults to `c(0.40, 0.65)`
* `tmRangeProbe`: defaults to `c(55, 70)`
* `concProbe`: defaults to `250`
* `concNa` Sodium ion concentration (in M) in the PCR reaction (for calculation of tm and delta G), defaults to `0.05` (50 mM)
* `temperature` Annealing temperature (in C), for calculation of Gibbs energy (delta G). Delta G is calculated for perfectly matching oligo-target duplexes using the nearest neighbor method [@SantaLuciaUnified], using formula, salt correction method and table values as described in [@santalucia2004thermodynamics]

All sequence variants must fulfill all the specified design constraints for an oligo to be considered as valid.

Oligos with sequence variants containing more than four consecutive runs of the same nucleotide (e.g. "AAAAA") and/or more than three consecutive runs of the same di-nucleotide (e.g. "TATATATA") are excluded for consideration. 

An error message will return if no oligos are found. If so, a good idea could be to re-run the process from Step 1 and increase the `ambiguityThreshold` in `consensusProfile()`, and/or relax the design constraints above. 

**Design using default settings**

To design oligos using default settings, I simply type: 

``` {r}
myOligos <- oligos(myConsensusProfile)
```

Results (first ten rows):

```{r, echo=FALSE}
myOligos[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The man page (`?oligos`) contains a detailed description of each variable. What may not be entirely self-explanatory is that some columns (`sequence` `gcContent`, `tm` and `deltaG`) can hold several values. All values within an entry can be retrieved by:   

```{r}
myOligos$sequence[[1]] ## All sequence variants of the first oligo 
myOligos$gcContent[[1]] ## GC-content of all variants of the first oligo 
myOligos$tm[[1]] ## Tm of all variants of the first oligo 
myOligos$deltaG[[1]] ## Delta G of all variants of the first oligo (in kcal/mole)
```

The primer and probe candidates can be visualized using `plotData()`:

```{r, fig.align="center", fig.width=12, fig.height=8}
plotData(myOligos)
```

It is also possible to select a specific oligo and plot the nucleotide distribution of the binding region, by subsetting the consensus profile from Step 1. I do this for the first primer:

```{r}
## Get the binding region of the first oligo (first row): 
bindingRegion <- myConsensusProfile[myConsensusProfile$position >= myOligos[1, ]$start & myConsensusProfile$position <= myOligos[1, ]$end, ]
```

It can be plotted in forward direction: 

```{r}
plotData(bindingRegion, type = "nucleotide")
```

Or as reverse complement, by specifying `rc = TRUE`: 

```{r}
plotData(bindingRegion, type = "nucleotide", rc = TRUE)
```

**Design primers and probes with modified settings**

I now increase the maximum allowed degeneracy and provide wider ranges on length and tm for primers, and lower the maximum allowed degeneracy for probes: 

```{r, fig.align="center", fig.width=12, fig.height=8}
myOligos2 <- oligos(myConsensusProfile, maxDegeneracyPrimer = 32, tmRangePrimer = c(50, 70), lengthPrimer = 16:24, maxDegeneracyProbe = 1)

plotData(myOligos2)
```

**Select a region of interest, and design primers using the mixed strategy**

Below, I specify a particular region of interest (position 1000 to 4000) and design primers using the mixed strategy. I select to not design probes, and also modify some of the other settings:

```{r, fig.align="center", fig.width=12, fig.height=8}

myRoi <- myConsensusProfile[myConsensusProfile$position >= 1000 & myConsensusProfile$position <= 4000, ]

myMixedPrimers <- oligos(myRoi, 
                         designStrategyPrimer = "mixed", 
                         maxDegeneracyPrimer = 8, 
                         tmRangePrimer = c(55, 75), 
                         minThreeEndCoverage = 0.99,  
                         lengthPrimer = 25:30, 
                         probe = FALSE)

plotData(myMixedPrimers)
```

Results (first ten rows):

```{r, echo=FALSE}
myMixedPrimers[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

In this case, identity refers to the mean identity of the target alignment at the 5' consensus part and coverage refers to the mean coverage of the target alignment at the 3' degenerate part. Values of 1 indicate perfect complementary to all targets in the input alignment. 

It is possible to subset the dataset in many different ways. For instance, I can look at the primers with an average 3' coverage higher than 0.9:

```{r, fig.align="center", fig.width=12, fig.height=8}
selection <- myMixedPrimers[myMixedPrimers$coverage > 0.90, ]

plotData(selection)
```

I now want to design an assay to amplify the region between position 2000 and 3000. To accomplish this, I can "mask" the primer dataset, to not place forward primers after position 2000 and to not place reverse primers after position 3000: 

```{r}
maskedSelection <- selection[
  (selection$fwd & selection$end < 2000) |
    (selection$rev & selection$start > 3000),
]

plotData(maskedSelection)
```

It is of course also possible to use R's standard functionality to visualize the object. For the dataset above, I select to plot the tm of all sequence variants of each oligo:

```{r}
boxplot(maskedSelection$tm)
```

### Step 3: `assays`

The next step is to find pairs of forward and reverse primers, and eventually, to combine them with probes. 

The arguments of `assays()` are:  

* `x`: the oligo dataset from Step 2
* `lengthRange`: Amplicon length range, defaults to `c(65, 120)`
* `maxTmDiffPrimers`: Maximum tm difference between the (mean tm) of the two primers (absolute value), defaults to `2`
* `tmDiffPrimersProbe`: Acceptable tm difference between the primer pair and probe, defaults to `c(0, 20)`. The tm difference is calculated by subtracting the mean tm of the probe with the mean tm of the primers. A positive value means that the average tm of the probe is higher than the average tm of the primer

Assays will contain probes if probes are present in the oligo dataset from Step 2. 

I design assays using default settings, from `myOligos`. An error message will return if no assays are found.

```{r}
myAssays <- assays(myOligos)  
```

Output (first ten rows): 

```{r, echo=FALSE}
myAssays[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The output contains many columns, so the best way of inspecting it is probably to type `View(as.data.frame(myAssays))` when using RStudio. 

Again, the output can be visualized using `plotData()`: 

```{r, fig.width=12, fig.height=6}
plotData(myAssays)
```

All assays are located within a conserved stretch of ~70 bases. This is also the target region for the most frequently used RT-qPCR assay for detection of HEV [@jothikumar2006broadly].

**Selection ROI/mask**

```{r}
myAssays2 <- assays(maskedSelection, lengthRange = c(1000, 2000))

plotData(myAssays2)
```

## Further handling of the data 

The oligo and assay region(s) can be inspected in more detail by using the consensus profile from Step 1. As an example, I select to take a closer look at the first assay in the dataset above.  

```{r}
## Find start and end positions for the first assay 
from <- myAssays[1, ]$start
to <- myAssays[1, ]$end

## Subset the RprimerProfile object based on these positions
selection <- myConsensusProfile[myConsensusProfile$position >= from & myConsensusProfile$position <= to, ] 
```

```{r, fig.width=12, fig.height=6}
plotData(selection)
```

The consensus amplicon sequence can be obtained by: 

```{r}
paste(selection$iupac, collapse = "")
```

It is also possible to highlight the amplicon region, using the argument `highlight`.

```{r fig 3, fig.width=12, fig.height=6}
plotData(myConsensusProfile, highlight = c(from, to))
```

## Export to file

Below, I show how to export the results to file, so that they can be analyzed further by other software. It is highly recommended to evaluate the primer and probe candidates for 1) the potential of primer-dimer and hairpin formation and 2) the potential to cross react with non-targets, before proceeding to wet-lab evaluation.

**Oligos and assays to fasta format**

The following functions can be used for converting all sequence variants of all oligos or assays to a DNAStringSet-object. The `revAsRc` option regulates whether reverse primers should be written as reverse complement or not. 

```{r}
oligosToDNAStringSet <- function(x, revAsRc = TRUE) { 
  fwd <- x$sequence[x$fwd]
  fwd <- unlist(lapply(seq_along(fwd), function(i) {
  names(fwd[[i]]) <- paste0(
    "fwd_", i, "_variant_", seq_along(fwd[[i]])
    ); fwd[[i]]
  }))
  rev <- if (revAsRc) x$sequenceRc[x$rev] else x$sequence[x$rev]
  rev <- unlist(lapply(seq_along(rev), function(i) {
  names(rev[[i]]) <- paste0(
    "rev_", i, "_variant_", seq_along(rev[[i]])
  ); rev[[i]]
  }))
  Biostrings::DNAStringSet(c(fwd, rev))
}

assaysToDNAStringSet <- function(x, revAsRc = TRUE) { 
  fwd <- x$sequenceFwd
  fwd <- unlist(lapply(seq_along(fwd), function(i) {
  names(fwd[[i]]) <- paste0(
    "assay_", i, "_fwd_variant_", seq_along(fwd[[i]])
    ); fwd[[i]]
  }))
  fwd <- Biostrings::DNAStringSet(fwd)
  rev <- x$sequenceRev 
  rev <- unlist(lapply(seq_along(rev), function(i) {
  names(rev[[i]]) <- paste0(
    "assay_", i, "_rev_variant_", seq_along(rev[[i]])
  ); rev[[i]]
  }))
  rev <- Biostrings::DNAStringSet(rev)
  if (!revAsRc) rev <- Biostrings::reverseComplement(rev)
  if ("sequencePr" %in% names(x)) {
    pr <- x$sequencePr 
    pr <- unlist(lapply(seq_along(pr), function(i) {
      names(pr[[i]]) <- paste0(
        "assay_", i, "_pr_variant_", seq_along(pr[[i]])
      ); pr[[i]]
    }))
    prRc <- Biostrings::DNAStringSet(pr)
    prRc <- x$sequenceRcPr 
    prRc <- unlist(lapply(seq_along(prRc), function(i) {
      names(prRc[[i]]) <- paste0(
        "assay_", i, "_pr_rc_variant_", seq_along(prRc[[i]])
      ); prRc[[i]]
    }))
    prRc <- Biostrings::DNAStringSet(prRc)
    } else {
    pr <- prRc <- NULL
  }
  c(fwd, rev, pr, prRc)  
}

## Example: convert the first two oligos in myOligos 
oligosToDNAStringSet(myOligos[1:2, ])

```

These objects can then easily be exported in fasta-format:

```r
toFile <- oligosToDNAStringSet(myOligos)
Biostrings::writeXStringSet(toFile, file = "myOligos.txt")

```

**Result tables**

Result tables can be saved to .txt or .csv-files, for instance: 

```r
write.csv(myAssays, file = "myAssays.csv", quote = FALSE, row.names = FALSE) 
write.table(myAssays, file = "myAssays.txt", quote = FALSE, row.names = FALSE) 
```

# Summary 

The design process is summarized below. 

```r
library(rprimer)

## Enter the filepath to an alignment with target sequences of interest 
filepath <- system.file("extdata", "example_alignment.txt", package = "rprimer")

## Import the alignment 
myAlignment <- Biostrings::readDNAMultipleAlignment(filepath, format = "fasta") 
myAlignment <- Biostrings::maskGaps(myAlignment, min.fraction = 0.5, min.block.width = 1)

## Design primers, probes and assays using default settings 
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
myOligos <- oligos(myConsensusProfile)
myAssays <- assays(myOligos)

```

# Classes and example data

The "rprimer" classes (`RprimerProfile`, `RprimerOligo` and `RprimerAssay`) are extensions of the `DataFrame` class from S4Vectors [@PagesS4], and behave in a similar manner as traditional data frames, with methods for `[`, `$`, `nrow`, `ncol`, `head`, `tail`, `rbind`, `cbind` etc. They can be coerced to traditional data frames by using `as.data.frame()`. 

Example datasets of each class are provided with the package, and are loaded by: 

```{r, warning=FALSE}
data("exampleRprimerProfile")
data("exampleRprimerOligo")
data("exampleRprimerAssay")
```

To provide reproducible examples, I've also included an alignment of class `Biostrings::DNAMultipleAlignment`. It is loaded by `data("exampleRprimerAlignment")`.

# Table values  

Lookup tables used for determination of complement bases, IUPAC consensus character codes, degeneracy and tm can be found by typing:

* `rprimer:::lookup$complement`
* `rprimer:::lookup$iupac`, `rprimer:::lookup$degenerates`, 
* `rprimer:::lookup$degeneracy` and 
* `rprimer:::lookup$nn`, respectively. 

# Session info 

```{r}
sessionInfo()
```

# References 
