---
title: "rprimer"
author: "Sofia"
package: rprimer
output: BiocStyle::html_document
bibliography: bibliography.bibtex
vignette: >
  %\VignetteIndexEntry{Getting started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, internal setup, echo=FALSE, warning=FALSE, message=FALSE}
library(kableExtra)
#devtools::load_all(".")
library(rprimer)
```

# Introduction

rprimer provides tools for analyzing sequence conservation 
and designing degenerate primers, probes and (RT)-(q/d)PCR assays from a 
multiple DNA sequence alignment. The package is developed primarily for sequence variable viruses, but it should be equally useful for other organisms with high sequence variability.  

In this vignette, I describe and demonstrate how to use rprimer by designing broadly reactive primers and probes for amplification and detection of hepatitis E virus (HEV), which is a sequence variable RNA virus and a common foodborne pathogen.

# Installation

rprimer can be installed from [GitHub](https://github.com/) with:

``` r
if (!requireNamespace("devtools", quietly = TRUE))
    install.packages("devtools")
devtools::install_github("sofpn/rprimer")
```
# Overview

The package contains five functions:

* `consensusProfile()`
* `oligos()`  
* `assays()` 
* `checkMatch()`
* `plotData()`

# Workflow

## Collection of target sequences and multiple alignment 

The first step is to identify and align target sequences of interest. It is important that the alignment accurately represents the generic variation within the intended target population, and that it does not contain any poorly aligned sequences. 

The file “example_alignment.txt” is provided with the package and contains an alignment of 200 HEV sequences. The filepath can be retrieved by:  

```r
system.file("extdata", "example_alignment.txt", package = "rprimer")
```

These sequences were collected by searching for “[a-z]”[porgn:__txid1678143] (the taxid of Ortohepevirus A, i.e., HEV) in the nucleotide database of NCBI GenBank, and filtering for sequence lengths > 6000 bp, to retrieve complete and nearly complete genomes. The search had 674 results (as of January 19, 2021). The sequences were downloaded (as complete record, fasta-file) and run through Hepatitis E virus genotyping tool version 0.1 (https://www.rivm.nl/mpf/typingtool/hev/, accessed January 19, 2021) to verify that they were correctly classified as Ortohepevirus A. Sequences that were not classified as Ortohepevirus A were removed, and the remaining ones (n = 642) were reduced to 200 by random selection, to not provide a too large example dataset for the package. These 200 sequences were aligned using the online version of mafft version 7 (https://mafft.cbrc.jp/alignment/server/, accessed January 19, 2021), with Auto settings.

## Data import {#Data}

The alignment must be imported to R using the `readDNAMultipleAlignment()` function from the Biostrings package [@PagesBios]. The input file can contain from one to several thousands of sequences. 

Below, I import the file "example_alignment.txt":  

```{r}
filepath <- system.file("extdata", "example_alignment.txt", package = "rprimer")

myAlignment <- Biostrings::readDNAMultipleAlignment(filepath, format = "fasta")
```

For some applications, there is often an interest in amplifying a specific region of the genome. In such cases, the alignment can be masked so that only the desired oligo binding regions are available for the subsequent design process. `colMask()` from Biostrings [@PagesBios] can be used for this task:

```{r}
## Mask everything but position 3000 to 4000 and 5000 to 6000
myMaskedAlignment <- myAlignment

Biostrings::colmask(myMaskedAlignment, invert = TRUE) <- c(3000:4000, 5000:6000)
```

## Design

### Step 1: `consensusProfile` {#Step1}

Once the alignment is imported, a consensus profile can be generated. At each position, the following information is collected: 

* The relative frequency of the letters A, C, G, T and “other”
* The relative frequency of gaps (-)
* Majority consensus base, which is the most frequently occurring letter among the letters A, C, G, T and - 
* Identity, which is the relative frequency of sequences, among all sequences with a DNA base (A, C, G, T) or gap (-), that has the majority consensus base
* IUPAC consensus character, which includes all DNA bases that occurs at a relative frequency higher than a user-specified ambiguity threshold. The threshold can range from 0 to 0.2; a value of 0 (default) will catch all the variation, but with the potential downside of generating oligos with high degeneracy, whereas a higher value will capture most of the variation, but with the potential downside of missing less common sequence variants
* Shannon entropy, which is a measurement of variability  [@shannon1951prediction]. It is calculated among all DNA bases that occurs at the specific position. A value of 0 indicate complete conservation among these bases, and a high value indicate high variability
* Coverage, which describes the proportion of sequences in the target alignment, among all sequences with a DNA base, that are covered by the IUPAC consensus character 

The consensus profile contains all the information needed for the subsequent design process.

`consensusProfile()` has two arguments: 

* `x`: a `Biostrings::MultipleDNAAlignment` object (see [Data import](#Data))
* `ambiguityThreshold`: "detection level" for an ambiguous base. All DNA bases that occur with a relative frequency higher than the specified value will be included in the IUPAC consensus character. Defaults to `0`, can range from `0` to `0.2`

```{r}
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
```

Results (row 100-110):

```{r, echo=FALSE}
myConsensusProfile[100:110, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The results be visualized by using `plotData()`:

```{r, fig.width=12, fig.height=6}
plotData(myConsensusProfile)
```

The dots represent the value at each position and the black lines represent centered running averages. High identity and low entropy values (in combination with low gap values) indicate high sequence conservation.

The data can be explored in more detail by zooming into a specific region of interest:

```{r, fig.width=12, fig.height=6}
## Select position 1000 to 1500 in the consensus profile 
selection <- myConsensusProfile[
  myConsensusProfile$position >= 1000 & myConsensusProfile$position <= 1500, 
  ]

plotData(selection)
```

The nucleotide distribution can be displayed by specifying `type = nucleotide`: 

```{r, fig.width=12, fig.height=6}
## Select position 1000 to 1020 in the consensus profile 
ntSelection <- myConsensusProfile[
  myConsensusProfile$position >= 1000 & myConsensusProfile$position <= 1020, 
]

plotData(ntSelection, type = "nucleotide")
```

An alignment with [masked columns](#Data) will be represented as follows:

```{r, fig.width=12, fig.height=6, warn=FALSE}
myMaskedConsensusProfile <- consensusProfile(myMaskedAlignment, ambiguityThreshold = 0.05)

plotData(myMaskedConsensusProfile)
```

### Step 2: `oligos` {#Step2}

The next step is to design oligos. Primers must be designed and probes are optional. Primers can be generated by using one of the two following strategies:

* The **ambiguous strategy** (default) generates primers from the IUPAC consensus sequence, which means that ambiguous bases can occur at any position in the primer

* The **mixed strategy** generates primers from both the majority and the IUPAC consensus sequence. These primers consist of a shorter degenerate part at the 3' end (~1/3 of the primer, targeting a conserved region) and a longer consensus part at the 5' end (~2/3 of the primer), which instead of having ambiguous bases contains the most probable nucleotide at each position. This strategy is based on the Consensus-Degenerate Hybrid Oligonucleotide Primer (CODEHOP) principle [@Rose2] and aims to allow amplification of highly variable targets using primers with minimal degeneracy. The idea is that the degenerate 3' end part will bind specifically to the target sequence in the initial PCR cycles, and promote amplification in spite of eventual mismatches at the 5' consensus part (since 5' end mismatches are generally less detrimental than 3' end mismatches) [@Rose2]. In this way, the generated products will match the 5' ends of all primers perfectly, which allows them to be efficiently amplified in later PCR cycles. To provide a sufficiently high melting temperature (tm) in spite of eventual 5' end mismatches, it is recommended to design relatively long primers (> 25 bases) when using this strategy 

Probes are always designed using the ambiguous strategy. 

The design settings (i.e., the arguments of `oligos()`) are:

* `x`: the consensus profile from [Step 1](#Step1)
* `maxGapFrequency`: maximum gap frequency (in the alignment) for primers and probes, defaults to `0.01`
* `lengthPrimer`: primer length, defaults to `18:22`
* `maxDegeneracyPrimer`: maximum degeneracy for primers, defaults to `4`
* `gcClampPrimer`: if primers should have a GC clamp, defaults to `TRUE`. A GC clamp is defined as the presence of two to three G or C:s within the last five bases (3' end) of the oligo. The presence of a GC clamp is thought to promote specific binding of the 3' end
* `avoidThreeEndRunsPrimer`: if primers with more than two runs of the same nucleotide at the terminal 3' end should be avoided (to reduce the risk of mispriming), defaults to `TRUE`
* `minThreeEndCoveragePrimer`: minimum allowed coverage at the 3' end (the last five bases) of the primer. Defaults to `0.98`. A value of `1` means that all bases of the 3' end are complementary to all sequence variants in the target alignment
* `gcRangePrimer`: GC-content range of primers, defaults to `c(0.40, 0.65)`
* `tmRangePrimer`: melting temperature range for primers (in Celcius degrees), defaults to `c(55, 65)`. Melting temperatures are calculated for perfectly matching oligo-target duplexes using the nearest neighbor method [@SantaLuciaUnified], using formula, salt correction method and table values as described in [@santalucia2004thermodynamics]. See the manual (`?oligos`) for more information 
* `concPrimer`: primer concentration in nM, defaults to `500` (for tm calculation)
* `designStrategyPrimer`: design strategy for primers, `"ambiguous"` or `"mixed"`, defaults to `"ambiguous"` 
* `probe`: if probes should be designed, defaults to `TRUE`
* `lengthProbe`: defaults to `18:22`
* `maxDegeneracyProbe`: defaults to `4`
* `avoidFiveEndGProbe`: if probes with a G at the terminal 5' end should be avoided (to prevent quenching of the 5' flourophore of hydrolysis probes), defaults to `TRUE`
* `gcRangeProbe`: defaults to `c(0.40, 0.65)`
* `tmRangeProbe`: defaults to `c(55, 70)`
* `concProbe`: defaults to `250`
* `concNa`: sodium ion concentration in the PCR reaction (in M), defaults to `0.05` (50 mM) (for delta S and tm calculation)

All sequence variants of an oligo must fulfill all specified design constraints to be considered as a potential candidate. 

Oligos with sequence variants containing more than four consecutive runs of the same nucleotide (e.g. "AAAAA") and/or more than three consecutive runs of the same di-nucleotide (e.g. "TATATATA") are excluded from consideration.

**[3 end complementarity]**

An error message will return if no oligos are found. If so, a good idea could be to re-run the process from [Step 1](#Step1) and increase the `ambiguityThreshold` in `consensusProfile()`, and/or relax the design constraints above. 

**Design with default settings**

``` {r}
myOligos <- oligos(myConsensusProfile)
```

Results (first ten rows):

```{r, echo=FALSE}
myOligos[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The manual (`?oligos`) contains a detailed description of each variable, but what may not be entirely self-explanatory is that some variables (e.g. `sequence` `gcContent` and `tm`) can hold several values in each entry (i.e., each entry is a list). All values within a specific row can be retrieved by:   

```{r}
myOligos$sequence[[1]] ## All sequence variants of the first oligo (i.e., first row) 
myOligos$gcContent[[1]] ## GC-content of all variants of the first oligo 
myOligos$tm[[1]] ## Tm of all variants of the first oligo 
```

The primer and probe candidates can be visualized using `plotData()`:

```{r, fig.align="center", fig.width=12, fig.height=8}
plotData(myOligos)
```

**Design with modified settings**

Below, I show how to modify some of the design constraints. 

```{r}
myOligosModified <- oligos(myConsensusProfile, 
                           maxDegeneracyPrimer = 32, 
                           tmRangePrimer = c(50, 70),
                           lengthPrimer = 16:24, 
                           maxDegeneracyProbe = 1)
```

There are now more primer candidates (due to relaxed constraints) and less probe candidates (due to tighter constraints).

```{r, fig.align="center", fig.width=12, fig.height=8}
plotData(myOligosModified)
```

**Mixed primers**

Below, I show how to design mixed primers. In this case, I select to not design probes. 

```{r}
myMixedPrimers <- oligos(myConsensusProfile, 
                         designStrategyPrimer = "mixed", 
                         probe = FALSE)
```

```{r, fig.align="center", fig.width=12, fig.height=8, warn=FALSE}
plotData(myMixedPrimers)
```

As a comparison, I do the same for the dataset where I [masked](#Data) all positions but 3000 to 4000 and 5000 to 6000:

```{r}
myMaskedMixedPrimers <- oligos(myMaskedConsensusProfile, 
                               designStrategyPrimer = "mixed", 
                               probe = FALSE)
```

```{r, fig.align="center", fig.width=12, fig.height=8, warn=FALSE}
plotData(myMaskedMixedPrimers)
```

It is also possible to mask the primer dataset directly, by using subsetting methods. Below, I show how to mask the `myMixedPrimers` dataset to only contain forward primers between position 3000 and 4000 and reverse primers between position 5000 and 6000: 

```{r}
fwdBindingRegion <- myMixedPrimers$fwd & 
  myMixedPrimers$start >= 3000 &
  myMixedPrimers$end <= 4000

revBindingRegion <- myMixedPrimers$rev & 
  myMixedPrimers$start >= 5000 &
  myMixedPrimers$end <= 6000

myMaskedMixedPrimers <- myMixedPrimers[fwdBindingRegion | revBindingRegion, ]
```

```{r, fig.align="center", fig.width=12, fig.height=8, warn=FALSE}
plotData(myMaskedMixedPrimers)
```

Result output (first ten rows):

```{r, echo=FALSE}
myMaskedMixedPrimers[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

An important point for mixed primers is that the identity in this case refers to the average identity within the 5' consensus part of the primer binding region and coverage refers to the average coverage of 3' degenerate part of the primer. For ambiguous oligos, both of these values are calculated for the oligo as a whole. For a detailed explanation of identity and coverage, see [Step 1](#Step1).

**Scoring system**

All valid oligos are scored based on their average identity, coverage, degeneracy, GC-content and tm range. The value can range from 0 to 12, where 0 is considered best. Detailed information about the scoring system can be found in the manual (`?oligos`).

The best scoring oligos can be retrieved as follows: 

```{r, fig.align="center", fig.width=12, fig.height=8}
## Get the minimum score from myOligos 
bestOligoScore <- min(myOligos$score)
bestOligoScore

## Make a subset that only oligos with the best score are included 
oligoSelection <- myOligos[myOligos$score == bestOligoScore, ]

## Plot these oligos 
plotData(oligoSelection)
```

**Oligo binding regions**

It is possible to select a specific oligo and plot the nucleotide distribution within the binding region, by subsetting the consensus profile from [Step 1](#Step1):

```{r}
## Get the binding region of the first oligo in the selection above (first row): 
bindingRegion <- myConsensusProfile[
  myConsensusProfile$position >= oligoSelection[1, ]$start & 
    myConsensusProfile$position <= oligoSelection[1, ]$end,
  ]
```

It can be plotted in forward direction: 

```{r}
plotData(bindingRegion, type = "nucleotide")
```

Or as reverse complement, by specifying `rc = TRUE`: 

```{r}
plotData(bindingRegion, type = "nucleotide", rc = TRUE)
```

### Step 3: `assays` {#Step3}

The final step is to find pairs of forward and reverse primers, and eventually, to combine them with probes. Probes will be added if the input dataset contains them. 

`assays()` has three arguments:   

* `x`: the oligo dataset from [Step 2](#Step2)
* `lengthRange`: amplicon length range, defaults to `c(65, 120)`
* `tmDifferencePrimers`: maximum allowed difference between the mean tm of the forward and reverse primer (in Celcius degrees, in absolute value). Defaults to `NULL`, which means that primers will be paired regardless of their tm.^[Note that the strategy of matching primer tm is somewhat flawed; what in reality is of interest is the amount of primer bound at the annealing temperature (ta). A PCR is most efficient if the two primers hybridize to the target at the same extent at the ta [@santalucia2007physical]. The result outputs from `oligos()` and `assays()` contain the change in both entropy (delta S, salt corrected) and enthalpy (delta H) when an oligo and a perfectly matching target sequence goes from random coil to duplex state, and these data can be used for calculating the proportion of hybridized primer at different temperatures; see [@santalucia2007physical].

An error message will return if no assays are found.

Below, I show how to design assays using default settings using the dataset `myOligos` from [Step 2](#Step2): 

```{r}
myAssays <- assays(myOligos)  
```

Output (first ten rows): 

```{r, echo=FALSE}
myAssays[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The output contains many columns, but can be viewed as a whole by using `View(as.data.frame(myAssays))`, if you are working in RStudio. 

Again, the results can be visualized using `plotData()`: 

```{r, fig.width=12, fig.height=6}
plotData(myAssays)
```

All candidate assays are located within a conserved stretch of ~70 bases. This is also the target region for the most frequently used RT-qPCR assay for detection of HEV, developed by Jothikumar and colleagues [@jothikumar2006broadly].

There are now over 1000 assays, but one way of reducing the amount is to subset the output dataset to only contain assays with the best total oligo scores (see the score variable in the table above). The best possible score is 0 and the worst possible score is 24 for an assay with only primers and 36 for an assay with probe (the maximum possible score for each oligo is 12; see [Step 2](#Step2) for more information).

```{r, fig.width=12, fig.height=6}
## Get the minimum score from myAssays
bestAssayScore <- min(myAssays$score)
bestAssayScore

## Make a subset that only contains the assays with the best scor 
myAssaySelection <- myAssays[myAssays$score == bestAssayScore, ]

## Plot these assays 
plotData(myAssaySelection)
```

## Further handling of the data 

### Oligo and assay binding regions 

Oligo and assay binding region(s) can be inspected in more detail by using the consensus profile from [Step 1](#Step1). As an example, I select to take a closer look at the first assay in `myAssaySelection` from [Step 3](#Step3).

The start and end position of an assay can be retrieved as follows:

```{r}
from <- myAssaySelection[1, ]$start
to <- myAssaySelection[1, ]$end
```

It is now possible to indicate the amplicon region, using the `highlight` argument in `plotData()`:

```{r fig 3, fig.width=12, fig.height=6}
plotData(myConsensusProfile, highlight = c(from, to))
```

To get a more detailed view, it is also possible to make a subset of the consensus profile to only contain the amplicon region: 

```{r}
myAssayRegion <- myConsensusProfile[
  myConsensusProfile$position >= from & 
    myConsensusProfile$position <= to, 
] 
```

And plot it:

```{r, fig.width=12, fig.height=6, fig.align="center"}
plotData(myAssayRegion)
plotData(myAssayRegion, type = "nucleotide")
```

The consensus amplicon sequence can be obtained by: 

```{r}
paste(myAssayRegion$iupac, collapse = "")
```

### Check match 

As a final step, it is often valuable to investigate how well the generated oligos or assays match with each individual target sequence in the input alignment. `checkMatch()` can be used for this purpose. The function is a wrapper to `Biostrings::vcountPDict()` [@PagesBios], and has two arguments: 

* `x`: an oligo or assay dataset from [Step 2](#Step2) or [3](#Step3)
* `target`: the target alignment used as input in [Step 1](#Step1)

The output gives information on both the proportion and names of target sequences that match perfectly as well as with one, two, three or four or more mismatches to the oligo within the intended oligo binding region (i.e., on target match). It also reports the proportion of target sequences that matches to the oligo with no more than four mismatches within *all other regions* in the alignment (i.e., off target match). However, note that the output does not say anything about the type, position or severity of the mismatches.

Below, I show how to use `checkMatch()` for both oligos and assays. The function is rather slow, especially if there are many target sequences, so a good idea could be to select only a few oligo or assay candidates to investigate. 

**Oligos**

```{r}
oligoSelectionMatch <- checkMatch(oligoSelection, target = myAlignment)
```

Output: 

```{r, echo=FALSE}
oligoSelectionMatch[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

As with many of the other outputs, some variables can hold several values in each row. All values within a specific row can be retrieved by: 

```{r}
## Get the id of all sequences that matches perfectly with the first oligo in the input dataset
oligoSelectionMatch$idPerfectMatch[[1]] 
```

The output can be visualized using `plotData()`: 

```{r, fig.width=12, fig.height=8}
plotData(oligoSelectionMatch)
```

Recall that off target match refers to the proportion of target sequences that matches with no more than four mismatches to all other regions than the intended oligo binding region. 

**Assays** 

```{r}
## Select the assays with the best (lowest) score  
assaySelection <- myAssays[myAssays$score == min(myAssays$score), ]

assaySelectionMatch <- checkMatch(assaySelection, target = myAlignment)
```

Output:

```{r, echo=FALSE}
assaySelectionMatch %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px")
```

The output can be visualized using `plotData()`: 

```{r, fig.width=12, fig.height=8}
plotData(assaySelectionMatch)
```

It is also possible to add the match information to the input oligo or assay by using `cbind()`. 

The columns named iupacSequence in `assaySelectionMatch` can be removed when pasting the two objects together, to avoid duplication:

```{r}
## Remove columns with 'iupacSequence' in their names in the match dataset
toAdd <- assaySelectionMatch[
  !grepl("iupacSequence", names(assaySelectionMatch))
]

## Combine the assay dataset with the match dataset  
assaySelection <- cbind(assaySelection, toAdd)
```

Output:

```{r, echo=FALSE}
assaySelection %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px")
```

## Export to file

Before proceeding to wet lab evaluation, it is highly recommended to evaluate the final primer and probe candidates for 1) the potential to form primer dimers and hairpin structures, and 2), the potential to (not) cross react with non-targets. 

These tasks are best performed by other software. Below, I show how to export the results to file so that they can be readily analyzed by other tools.  

**Result tables**

All result tables can be saved directly to .txt or .csv-files, for instance: 

```r
write.csv(myAssays, file = "myAssays.csv", quote = FALSE, row.names = FALSE) 
write.table(myAssays, file = "myAssays.txt", quote = FALSE, row.names = FALSE) 
```

**Oligos and assays to fasta format**

It is also possible to export the oligo sequences in fasta-format. To do this, the oligo or assay(s) of interest must first be cocered to a `Biostrings::DNAStringSet` object, as  follows:

```{r}
## Convert the first two oligos 
as(myOligos[1:2, ], "DNAStringSet")
```

```{r}
## Convert the first two assays 
as(myAssays[1:2, ], "DNAStringSet")
```

Note that all sequences will be written in 3' to 5' direction, and that all sequence variants of each oligo will be printed.  

The sequences can now be saved as fasta format, for example: 

```r
toFile <- as(myOligos, "DNAStringSet")
Biostrings::writeXStringSet(toFile, file = "myOligos.txt")

```

# Summary 

The design process is summarized below. 

```r
library(rprimer)

## Enter the filepath to an alignment with target sequences of interest 
filepath <- system.file("extdata", "example_alignment.txt", package = "rprimer")

## Import the alignment 
myAlignment <- Biostrings::readDNAMultipleAlignment(filepath, format = "fasta") 

## Design primers, probes and assays (modify settings if needed) 
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
myOligos <- oligos(myConsensusProfile)
myAssays <- assays(myOligos)

## Visualize the results 
plotData(myConsensusProfile)
plotData(myOligos)
plotData(myAssays)

## Show result tables (in RStudio)
View(as.data.frame(myConsensusProfile))
View(as.data.frame(myOligos))
View(as.data.frame(myAssays))
```

# Classes and example data

The "rprimer" classes (`RprimerProfile`, `RprimerOligo`, `RprimerAssay`, `RprimerMatchOligo` and `RprimerMatchAssay`) extends the `DataFrame` class from S4Vectors [@PagesS4], and behave in a similar way as traditional data frames, with methods for `[`, `$`, `nrow()`, `ncol()`, `head()`, `tail()`, `rbind()`, `cbind()` etc. They can be coerced to traditional data frames by using `as.data.frame()``. 

Example datasets of each class are provided with the package, and are loaded by: 

```{r, warning=FALSE}
data("exampleRprimerProfile")
data("exampleRprimerOligo")
data("exampleRprimerAssay")
data("exampleRprimerMatchOligo")
data("exampleRprimerMatchAssay")
```

To provide reproducible examples, I have also included an alignment of class `Biostrings::DNAMultipleAlignment`. It is loaded by `data("exampleRprimerAlignment")`.

# Table values  

Tables used for determination of complement bases, IUPAC consensus character codes, degeneracy and nearest neighbors can be found by typing:

* `rprimer:::lookup$complement`
* `rprimer:::lookup$iupac`, `rprimer:::lookup$degenerates`, 
* `rprimer:::lookup$degeneracy` and 
* `rprimer:::lookup$nn`, respectively. 

# Source code 

The source code is available at https://github.com/sofpn/rprimer. 

# Citation

To cite this package, please use: `citation("rprimer")`.

# Session info 

This document was generated under the following conditions:

```{r}
sessionInfo()
```

# References 
