---
title: "rprimer"
author: "Sofia Persson"
package: rprimer
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Getting started with rprimer}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# Introduction

Primer and probe design is a central part of PCR assay development. Successful amplification and detection depend on many factors, such as primer and probe length, GC-content, melting temperature, sequence complexity and target sequence conservation. For a set of target sequences of interest, it is often difficult to identify regions that meet all, or even most of these requirements.

rprimer provides tools for designing (RT)-(q/d)PCR assays from a multiple DNA sequence alignment, which can contain up to several thousands of sequences. Primers and probes are designed from user specified criteria on length, GC-content and melting temperature, maximum allowed degeneracy and target gap frequency. Target regions with low sequence complexity are avoided. For primers, it is also possible to specify a threshold for minimum 3'-end conservation and enforce a GC-clamp to increase the probability of amplification. Assays can be generated with or without probe, and are designed upon user specified amplicon length and maximum allowed difference in melting temperature between primers, and between the primer pair and probe.  

In this document, I demonstrate how to use rprimer by designing an RT-q/dPCR assay for detection of hepatitis E virus, which is a highly variable RNA virus. 

## Functions

The design process is built on three functions: 

* `getConsensusProfile()`: takes a `Biostrings::MultipleDNAAlignment` object (Pagès et al., 2020) as input and returns an `RprimerProfile` object, which is used as input for;
* `getOligos()`: returns an `RprimerOligo` object, which is used as input for; 
* `getAssays()`: returns an `RprimerAssay` object

## Data structures 

The `Rprimer`-classes are extensions of the `DataFrame` class from S4Vectors (Pagès et al., 2020), and behave in a similar manner as traditional data frames (with methods for e.g. [, $, nrow, ncol, head, tail). They can be coerced to traditional data frames by using `as.data.frame()`. 

Example data sets of each class are provided with the package, and can be loaded by: 

```{r, warning=FALSE}
data("exampleRprimerProfile")
data("exampleRprimerOligo")
data("exampleRprimerAssay")
```

These classes can be visualized using the generic function `plotData()`, e.g. `plotData(exampleRprimerProfile)`. 

To provide reproducible examples, I've also included an alignment of class `Biostrings::MultipleDNAAlignment` (Pagès et al., 2020), which can be loaded by `data("exampleRprimerAlignment")`.

# Installation

rprimer can be installed from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("sofpn/rprimer")
```

Setup for the code in this document: 

```{r, internal setup, echo=FALSE, warning=FALSE, message=FALSE}
library(kableExtra)
```
```{r setup, message = FALSE, warning = FALSE}
library(rprimer)
library(magrittr)
library(Biostrings)
#devtools::load_all(".")
```

# Workflow

## To start: import data

The first step is to import the alignment with the target sequences of interest and, if preferred, mask positions with high gap frequency. `readDNAMultipleAlignment()` and `maskGaps()` from Biostrings (Pagès et al., 2020) do the work for this part. The file "example_alignment.txt" is provided with the package and contains 100 hepatitis E virus sequences.  

I mask all positions with at least 50 % gaps. However, masking positions with high gap frequency should be done with caution, since it may lead to that oligos are placed in positions were some sequences have inserts. A good idea could therefore be to test both with and without gap mask. 

```{r}
infile <- system.file('extdata', 'example_alignment.txt', package = 'rprimer')

myAlignment <- infile %>%
  Biostrings::readDNAMultipleAlignment(., format = "fasta") %>%
  Biostrings::maskGaps(., min.fraction = 0.5, min.block.width = 1) 
```

## Step 1: `getConsensusProfile` 

`getConsensusProfile()` takes a `Biostrings::DNAMultipleAlignment` object as input and returns all the information needed for the subsequent design process. Note that positions that are masked in the previous step are excluded. 

```{r}
myConsensusProfile <- getConsensusProfile(myAlignment, iupacThreshold = 0.05)
```

Output (first ten rows):

```{r, echo=FALSE}
myConsensusProfile[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

Some comments on the data: 

* Majority refers to the majority consensus sequence, which is the most frequently occurring base. Identity is the proportion of that base when gaps and other bases than A, C, G and T are not taken into account

* The IUPAC consensus sequence includes wobble bases according to the IUPAC-nomenclature. It includes all DNA bases (A, C, G, T) that occurs with a frequency higher than the stated `iupacThreshold`. In my example, I set the threshold to `0.05`, which means that all bases that occur in more than 5 % of the sequences will be accounted for when the IUPAC base will be determined 

* Entropy refers to Shannon entropy, which is a measurement of variability. A value of zero indicate no variability and a high value indicate high variability. Gaps and other bases than A, C, G and T are not included in this calculation 

The data can be visualized with `plotData()`, and specific regions can be highlighted using the optional arguments `shadeFrom` and `shadeTo`. The most conserved region of the sequences in my data appears to be between position 5000-5500:

```{r, fig.width=12, fig.height=6}
plotData(myConsensusProfile, shadeFrom = 5000, shadeTo = 5500)
```

The black lines represent centered running averages and the blue dots represent the value at each position. 

## Step 2: `getOligos`

`getOligos()` searches for oligos (primers and probes) from an `RprimerProfile`-object. All oligos are shown in both majority (without degenerate bases) and IUPAC format (with degenerate bases). Oligos are designed from the following constraints:  

* `lengthPrimer` Primer length, defaults to `18:22`
* `maxGapFrequencyPrimer` Maximum gap frequency for primers, defaults to `0.1`
* `maxDegeneracyPrimer` Maximum number of variants of each primer, defaults to `4`
* `gcClampPrimer` If primers must have a GC-clamp, defaults to `TRUE`. A GC-clamp is identified as two to three G or C:s within the last five bases (3' end) of the primer
* `avoid3endRunsPrimer` If primers with more than two runs of the same nucleotide at the terminal 3' end should be avoided, defaults to `TRUE`
* `minEndIdentityPrimer` Optional. Minimum allowed identity at the 3' end (i.e. the last five bases). E.g., if set to `1`, only primers with complete target conservation at the 3' end will be considered
* `gcRangePrimer` GC-content-range for primers, defaults to `c(0.45, 0.55)`
* `tmRangePrimer` Melting temperature (Tm) range for primers, defaults to `c(55, 65)` 
* `concPrimer` Primer concentration in nM (for Tm calculation), defaults to `500`
* `probe` If probes should be designed as well, defaults to `TRUE`
* `lengthProbe` Probe length, defaults to `18:22`
* `maxGapFrequencyProbe` Maximum gap frequency for probes, defaults to `0.1` 
* `maxDegeneracyProbe` Maximum number of variants of each probe, defaults to `4`
* `avoid5endGProbe` If probes with a G at the terminal 5' end should be avoided, defaults to `TRUE`
* `gcRangeProbe` GC-content-range for probes, defaults to `c(0.45, 0.55)`
* `tmRangeProbe` Melting temperature (Tm) range for probes, defaults to `c(55, 70)`
* `concProbe` Probe concentration in nM (for Tm calculation), defaults to `250`
* `concNa` Sodium ion concentration in the PCR reaction (for Tm calculation), defaults to `0.05` M (50 mM)
* `showAllVariants` If sequence, GC-content and Tm should be presented for all variants of each oligo (in case of degenerate bases).`TRUE` (slower) or `FALSE` (faster), defaults to `TRUE`

In addition, `getOligos()` avoids:

* Majority oligos with more than than three consecutive runs of the same dinucleotide (e.g. "TATATATA")
* Majority oligos with more than four consecutive runs of the same nucleotide  (e.g. "AAAAA")
* Majority oligos that are duplicated (to prevent binding at several places on the genome)

An error message will return if no oligos are found. 

Below, I design both primers and probes. For primers, I use very strict constraints on degeneracy (not more than 2) and minimum end identity (= 1). This means that only the most conserved regions will be considered as primer binding sites. 

``` {r}
myOligos <- getOligos(myConsensusProfile,
                      lengthPrimer = 18:22,
                      maxGapFrequencyPrimer = 0.05,
                      maxDegeneracyPrimer = 2,
                      gcClampPrimer = TRUE,
                      avoid3EndRunsPrimer = TRUE,
                      minEndIdentityPrimer = 1,
                      gcRangePrimer = c(0.45, 0.65),
                      tmRangePrimer = c(55, 65),
                      concPrimer = 500,
                      probe = TRUE,
                      lengthProbe = 16:24,
                      maxGapFrequencyProbe = 0.05,
                      maxDegeneracyProbe = 4,
                      avoid5EndGProbe = TRUE, 
                      gcRangeProbe = c(0.45, 0.65),
                      tmRangeProbe = c(55, 70),
                      concProbe = 250,
                      concNa = 0.05,
                      showAllVariants = TRUE)
```

Of course, it is possible to design primers and probes with default settings, or by changing just a few settings. For instance:  

```r
# getOligos(myConsensusProfile)
# getOligos(myConsensusProfile, maxDegeneracyPrimer = 8, probe = FALSE)
```
Output (first ten rows): 

```{r, echo=FALSE}
myOligos[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

Some comments on the data: 

* Type indicates whether the oligo is a primer or probe candidate 
* `NA` means that the particular oligo did not meet the specified design criteria (e.g if a primer lacked GC-clamp when `gcClampPrimer` was set to `TRUE`)
* Degeneracy tells how many variants there are of that particular oligo. An oligo without wobble bases will have a value of 1
* Melting temperature is calculated using the nearest-neighbor method (SantaLucia, 1998), with initiation parameters as described by Allawi & SantaLucia 1997, and salt correction formula as described by SantaLucia et al., 1996
* Identity shows the average identity score of the oligo. A high identity score indicates that the target binding region is conserved
* If `showAllVariants` was set to `TRUE`, the columns `all` and `allRc` contain all sequence variants of the forward and reverse variant of the primer, respectively. Take the first primer candidate as an example:

```{r}
myOligos$iupac[1] # The IUPAC variant of the first oligo 
myOligos$all[[1]] # All variants of that oligo 
```
* The columns `gcAll` and `tmAll` give the GC-content and melting temperature of each variant:  

```{r}
myOligos$gcAll[[1]] 
myOligos$tmAll[[1]] 
```
All primer and probe candidates can be visualized using `plotData()`:

```{r, fig.align="center", fig.width=12, fig.height=8}
plotData(myOligos)
```

The upper plot shows the location of the primer and probe candidates, and the lower plots shows the characteristics of the oligo candidates. 

## Step 3: `getAssays`

`getAssays()` finds pairs of forward and reverse primers and combines them with probes, if present (i.e., if `probe = TRUE` was used in the previous step). The design process is based on the following criteria:

* `length` Amplicon length, defaults to `65:120`
* `maxTmDifferencePrimers` Maximum Tm difference between the two primers (absolute value, calculated for majority primers), defaults to `2`
* `tmDifferencePrimersProbe` Acceptable Tm difference between the primers (average Tm of the primer pair) and probe, defaults to `c(0, 20)`. The Tm-difference is calculated by subtracting the Tm of the (majority) probe with the average Tm of the (majority) primer pair. Hence, a negative Tm-difference means that the Tm of the probe is lower than the average Tm of the primer pair

An error message will return if no assays are found.

```{r}
myAssays <- getAssays(myOligos, 
                      length = 65:100,
                      maxTmDifferencePrimers = 2,
                      tmDifferencePrimersProbe = c(0, 10))
```

Output (first ten rows): 

```{r, echo=FALSE}
myAssays[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The output contains many columns, so the most sensible way of inspecting it is probably to use `View(myAssays)`, if you are using RStudio. 

Some comments on the output: 

* Mean identity specifies the average identity score of primers and probe (if present). A high value indicates that the oligos bind to conserved regions in the genome 
* Total degeneracy denotes the total number of oligos in the assay. If no wobble bases are present in primers or probes, the total degeneracy would be 3 
* Probes can be either positive or negative sense. If both the positive and negative sense probe are valid for a specific assay, the probe with the least number of Gs will be selected 

Again, the output can be visualized using `plotData()`: 

```{r, fig.width=12, fig.height=6}
plotData(myAssays)
```

I notice that all assays are located in the conserved region between position 5000-5500. There are many assay candidates, and they can be sorted on e.g. total degeneracy score: 

```{r}
myAssays <- myAssays[order(myAssays$totalDegeneracy), ]
```

It is also possible to extract assays fulfilling specific criteria, for instance, assays with a total degeneracy below 6:

```{r}
mySelectedAssays <- myAssays[myAssays$totalDegeneracy < 6, ]
```

## Further handling of the data 

The oligo or assay region(s) can be inspected further by using the `RprimerProfile` object. As an example, I select to look at the first assay in `myAssays`: 

```{r}
assayStart <- myAssays[1, ]$start
assayEnd <- myAssays[1, ]$end
myAssayRegion <- myConsensusProfile[myConsensusProfile$position >= assayStart & myConsensusProfile$position <= assayEnd, ] 
```

The nucleotide distribution within the amplicon can be visualized with `plotNucleotides()`. The `rc` option regulates whether the sequence should be displayed as a reverse complement or not.

```{r, fig.width=12, fig.height=4}
plotNucleotides(myAssayRegion, rc = FALSE) 
```
I can of course also use `plotData()` for the assay region:

```{r, fig.width=12, fig.height=6}
plotData(myAssayRegion)
```

The majority amplicon sequence can be obtained by: 

```{r}
paste(myAssayRegion$majority, collapse = "")
```
The results can be saved to .txt or .csv-files, for instance: 

```r
write.csv(myAssays, file = "myAssays.csv", quote = FALSE, row.names = FALSE) 
write.table(myAssays, file = "myAssays.txt", quote = FALSE, row.names = FALSE) 
```

## Summary 

The design process can be summarized in the following pipeline. In this case, I use default settings for oligo and assay design. 

```r
## Enter the filepath to the alignment here 
filepath <- system.file('extdata', 'example_alignment.txt', package = 'rprimer')

myAlignment <- filepath %>%
  Biostrings::readDNAMultipleAlignment(., format = "fasta") %>%
  Biostrings::maskGaps(., min.fraction = 0.5, min.block.width = 1)
myConsensusProfile <- getConsensusProfile(myAlignment, iupacThreshold = 0.05)
myOligos <- getOligos(myConsensusProfile)
myAssays <- getAssays(myOligos)

```

# Limitations  

rprimer takes many factors into account in primer, probe and assay design, but not all. For instance, successful amplification is highly dependent on the absence of stable dimers and hairpin structures of primers and probes. Also, secondary structures within the target region can greatly affect reverse transcription efficiency. It is therefore a good idea to make predicitons in silico before selecting the final candidate(s) for wet-lab evaluation.  

# Session info 

```{r}
sessionInfo()
```

# References 

Allawi, H. & SantaLucia, J. (1997) Thermodynamics and NMR of Internal G-T Mismatches in DNA. Biochemistry, 36, 34: 1058-110594

Pagès, H., Aboyoun, P., Gentleman, R., & DebRoy, S. (2020). Biostrings: Efficient manipulation of biological strings. R package version 2.57.2

Pagès, H., Lawrence M., & Aboyoun, P. (2020). S4Vectors: Foundation of vector-like and list-like containers in Bioconductor. R package version 0.27.12

SantaLucia, J., et al. (1996) Improved Nearest-Neighbor Parameters for Predicting DNA Duplex Stability. Biochemistry, 35: 3555-3562

SantaLucia, J. (1998) A unified view of polymer, dumbell, and oligonucleotide DNA nearest-neighbor thermodynamics. Proc. Natl. Acad. Sci. USA, 95: 1460-1465
