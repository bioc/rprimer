---
title: "rprimer"
author: "Sofia"
package: rprimer
output: BiocStyle::html_document
bibliography: bibliography.bibtex
vignette: >
  %\VignetteIndexEntry{Getting started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r, internal setup, echo=FALSE, warning=FALSE, message=FALSE}
library(kableExtra)
#
devtools::load_all(".")
library(rprimer)
```

# Introduction

Reverse transcription (RT) PCR based methods have become the gold standard for detection and quantification of viral nucleic acids in a wide variety of fields, including clinical diagnosis and food safety control. Successful RT-PCR analysis depends on several factors, but oligo (primer and probe) design is arguably the most critical part of assay development [@Bustin]. Poorly designed primers may reduce the efficiency of the RT or PCR and poorly designed probes may not hybridize properly with the target, which both can lead to underestimation of the target concentration or false negative results.

The ideal oligo binds exclusively to a conserved part of the target of interest and does not fold or form stable interactions (primer dimers) with other oligos. Unfortunately, it is often both difficult and time consuming to identify target regions and oligo combinations that meet these criteria. Moreover, many viruses, especially RNA viruses who lack replication proofreading mechanism, evolve quickly and thereby pose great sequence diversity across large parts of their genomes. This makes sequence conservation analysis a key step of the design process, since primers or probes that captures only a part of the target variation can cause severe detection and quantification bias. 

A common approach for amplifying sequence variable targets is to use degenerate oligos. A degenerate oligo has one or more positions with several possible bases, and the degeneracy refers to the number of unique sequence variants it encompasses. The ambiguous bases are specified by a code system determined by IUPAC. For instance, the IUPAC consensus base K can be either G or T, and N can be A, C, G or T. For some applications, it is not uncommon to use primers with up to several hundreds of sequence variants. However, as the degeneracy increases, the fraction of primers that match perfectly to the target sequence and the synthesized products decreases, which risks to reduce the amplification efficiency [@Rose]. The most ideal design strategy would therefore be to find oligo binding regions with as low degeneracy as possible.

rprimer provides tools for analyzing sequence conservation and designing degenerate DNA oligos. A multiple DNA sequence alignment with intended target sequences is used as input and the outputs consist of data frames (tabular data) and dashboard-like plots. 

In this document, I describe and demonstrate how to use the package by designing broadly reactive primers and probes for amplification and detection of hepatitis E virus (HEV), which is a sequence variable RNA virus and a common foodborne pathogen.  

The workflow is developed primarily for sequence variable viruses, but it should be equally useful for other organisms with high sequence variability. 

# Installation

rprimer can be installed from [GitHub](https://github.com/) with:

``` r
if (!requireNamespace("devtools", quietly = TRUE))
    install.packages("devtools")
devtools::install_github("sofpn/rprimer")
```
# Overview

The package contains six functions:

* `consensusProfile()`
* `oligos()`  
* `assays()` 
* `checkMatch()`
* `plotData()`
* `convertToDNAStringSet()`

# Workflow

## Collection of target sequences and multiple alignment 

The first step is to identify and align target sequences of interest. It is important that the alignment accurately represents the generic variation within the intended target population, and that it does not contain any poorly aligned sequences. 

The file “example_alignment.txt” is provided with the package and contains an alignment of 200 HEV sequences. The filepath can be retrieved by:  

```r
system.file("extdata", "example_alignment.txt", package = "rprimer")
```

These sequences were collected by searching for “[a-z]”[porgn:__txid1678143] (the taxid of Ortohepevirus A, i.e., HEV) in the nucleotide database of NCBI GenBank, and filtering for sequence lengths > 6000 bp, to retrieve complete and nearly complete genomes. The search had 674 results (as of January 19, 2021). The sequences were downloaded (as complete record, fasta-file) and run through Hepatitis E virus genotyping tool version 0.1 (https://www.rivm.nl/mpf/typingtool/hev/, accessed January 19, 2021) to verify that they were correctly classified as Ortohepevirus A. Sequences that were not classified as Ortohepevirus A were removed, and the remaining ones (n = 642) were reduced to 200 by random selection, to not provide a too large example dataset for the package. These 200 sequences were aligned using the online version of mafft version 7 (https://mafft.cbrc.jp/alignment/server/, accessed January 19, 2021), with Auto settings.

## Data import {#Data}

The alignment must be imported to R using the `readDNAMultipleAlignment()` function from the Biostrings package [@PagesBios]. The input file can contain from one to several thousands of sequences. 

Below, I import the file "example_alignmnent.txt":  

```{r}
filepath <- system.file("extdata", "example_alignment.txt", package = "rprimer")

myAlignment <- Biostrings::readDNAMultipleAlignment(filepath, format = "fasta")
```

## Design

### Step 1: `consensusProfile` {#Step1}

Once the alignment is imported, a consensus profile can be generated. At each position, information is collected about: 

* The relative frequency of the letters A, C, G, T and “other”
* The relative frequency of gaps (-)
* Majority consensus base, which is the most frequently occurring letter among the letters A, C, G, T and - 
* Identity, which is the relative frequency of sequences, among all sequences with a DNA base (A, C, G, T) or gap (-), that has the majority consensus base
* IUPAC consensus character, which includes all DNA bases that occurs at a relative frequency higher than a user-specified ambiguity threshold. The threshold can range from 0 to 0.2; a value of 0 (default) will catch all the variation, but with the potential downside of generating oligos with high degeneracy, whereas a higher value will capture most of the variation, but with the potential downside of missing less common sequence variants
* Shannon entropy, which is a measurement of variability  [@shannon1951prediction]. It is calculated among all DNA bases that occurs at the specific position. A value of 0 indicate complete conservation among these bases, and a high value indicate high variability
* Coverage, which describes the proportion of sequences in the target alignment, among all sequences with a DNA base, that are covered by the IUPAC consensus character 

`consensusProfile()` has two arguments: 

* `x`: a `Biostrings::MultipleDNAAlignment` object (see [Data import](#Data))
* `ambiguityThreshold`: "detection level" for an ambiguous base. All DNA bases that occur with a relative frequency higher than the specified value will be included when the IUPAC consensus character is determined. Defaults to `0`, and can range from `0` to `0.2`. 

Below, I  make a consensus profile from `myAlignment` with an ambiguity threshold of 5 %: 

```{r}
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
```

Results (row 100-110):

```{r, echo=FALSE}
myConsensusProfile[100:110, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The results can be visualized using `plotData()`:

```{r, fig.width=12, fig.height=6}
plotData(myConsensusProfile)
```

The dots represent the value at each position and the black lines represent centered running averages. High identity and low entropy values (in combination with low gap values) indicate high sequence conservation.

It is possible to explore the data in more detail by zooming into a specific region of interest:

```{r, fig.width=12, fig.height=6}
## Select position 1000 to 1500 in the consensus profile 
selection <- myConsensusProfile[
  myConsensusProfile$position >= 1000 & myConsensusProfile$position <= 1500, 
  ]

plotData(selection)
```

It is also possible to look closer at the nucleotide distribution, by specifying `type = nucleotide`: 

```{r, fig.width=12, fig.height=6}
## Select position 1000 to 1020 in the consensus profile 
ntSelection <- myConsensusProfile[
  myConsensusProfile$position >= 1000 & myConsensusProfile$position <= 1020, 
  ]

plotData(ntSelection, type = "nucleotide")
```

### Step 2: `oligos` {#Step2}

The next step is to design oligos. Primers must be designed and probes are optional. Primers can be generated by using one of the two following strategies:

* The **ambiguous strategy** (default) generates primers from the IUPAC consensus sequence, which means that ambiguous bases can occur at any position in the primer

* The **mixed strategy** generates primers from both the majority and the IUPAC consensus sequence. These primers consist of a shorter degenerate part at the 3' end (~1/3 of the primer, targeting a conserved region) and a longer consensus part at the 5' end (~2/3 of the primer), which instead of having ambiguous bases contains the most probable nucleotide at each position. This strategy is based on the Consensus-Degenerate Hybrid Oligonucleotide Primer (CODEHOP) principle [@Rose2], and aims to allow amplification of highly variable targets using minimally degenerate primers. The idea is that the degenerate 3' end part will bind specifically to the target sequence in the initial PCR cycles, and promote amplification in spite of eventual mismatches at the 5' consensus part (since 5' end mismatches are generally less detrimental than 3' end mismatches) [@Rose2]. In this way, the generated products will match the 5' ends of all primers perfectly, which allows them to be efficiently amplified in later PCR cycles. To provide a sufficiently high melting temperature (tm) in spite of mismatches, it is recommended to design relatively long primers (> 25 bases) when using this strategy  

Probes are always designed using the ambiguous strategy. 

The design settings (i.e., the arguments of `oligos()`) are:

* `x`: the consensus profile from [Step 1](#Step1)
* `maxGapFrequency`: maximum gap frequency (in the alignment) for primers and probes, defaults to `0.01`
* `lengthPrimer`: primer length, defaults to `18:22`
* `maxDegeneracyPrimer`: maximum degeneracy for primers, defaults to `4`
* `gcClampPrimer`: if primers should have a GC clamp, defaults to `TRUE`. A GC clamp is defined as the presence of two to three G or C:s within the last five bases (3' end) of the oligo. The presence of a GC clamp is thought to promote specific binding of the 3' end
* `avoidThreeEndRunsPrimer`: if primers with more than two runs of the same nucleotide at the terminal 3' end should be avoided (to reduce the risk of mispriming), defaults to `TRUE`
* `minThreeEndCoveragePrimer`: minimum allowed coverage at the 3' end (the last five bases) of the primer. Defaults to `0.98`. A value of `1` means that all bases of the 3' end are complementary to all sequence variants in the target alignment
* `gcRangePrimer`: GC-content range of primers, defaults to `c(0.40, 0.65)`
* `tmRangePrimer`: melting temperature range for primers (in Celcius degrees), defaults to `c(55, 65)`. Melting temperatures are calculated for perfectly matching oligo-target duplexes using the nearest neighbor method [@SantaLuciaUnified], using formula, salt correction method and table values as described in [@santalucia2004thermodynamics]. See the manual (`?oligos`) for more information 
* `concPrimer`: primer concentration in nM, defaults to `500` (for tm calculation)
* `designStrategyPrimer`: design strategy for primers, `"ambiguous"` or `"mixed"`, defaults to `"ambiguous"` 
* `probe`: if probes should be designed, defaults to `TRUE`
* `lengthProbe`: defaults to `18:22`
* `maxDegeneracyProbe`: defaults to `4`
* `avoidFiveEndGProbe`: if probes with a G at the terminal 5' end should be avoided (to prevent quenching of the 5' flourophore of hydrolysis probes), defaults to `TRUE` 
* `gcRangeProbe`: defaults to `c(0.40, 0.65)`
* `tmRangeProbe`: defaults to `c(55, 70)`
* `concProbe`: defaults to `250`
* `concNa`: sodium ion concentration (in M) in the PCR reaction, defaults to `0.05` (50 mM) (for delta S and tm calculation)

All sequence variants of an oligo must fulfill all specified design constraints to be considered as a potential candidate. 

Oligos with sequence variants containing more than four consecutive runs of the same nucleotide (e.g. "AAAAA") and/or more than three consecutive runs of the same di-nucleotide (e.g. "TATATATA") are excluded from consideration.

An error message will return if no oligos are found. If so, a good idea could be to re-run the process from [Step 1](#Step1) and increase the `ambiguityThreshold` in `consensusProfile()`, and/or relax the design constraints above. 

**Design with default settings**

In the first example, I show how to design oligos using the default settings as described above.

``` {r}
myOligos <- oligos(myConsensusProfile)
```

Results (first ten rows):

```{r, echo=FALSE}
myOligos[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The manual (`?oligos`) contains a detailed description of each variable, but what may not be entirely self-explanatory is that some variables (e.g. `sequence` `gcContent` and `tm`) can hold several values in each row. All values within a specific row can be retrieved by:   

```{r}
myOligos$sequence[[1]] ## All sequence variants of the first oligo (i.e., first row) 
myOligos$gcContent[[1]] ## GC-content of all variants of the first oligo 
myOligos$tm[[1]] ## Tm of all variants of the first oligo 
```

The primer and probe candidates can be visualized using `plotData()`:

```{r, fig.align="center", fig.width=12, fig.height=8}
plotData(myOligos)
```

All valid oligos are scored based on their average identity, coverage, degeneracy, GC-content and tm range. The value can range from 0 to 12, where 0 is considered best. Detailed information about the scoring system can be found in the manual (`?oligos`).

The best scoring oligos are shown below:

```{r, fig.align="center", fig.width=12, fig.height=8}
## Get the minimum score from myOligos 
bestOligoScore <- min(myOligos$score)
bestOligoScore

## Make a subset that only oligos with the best score are included 
oligoSelection <- myOligos[myOligos$score == bestOligoScore, ]

## Plot these oligos 
plotData(oligoSelection)
```

It is also possible to select a specific oligo and plot the nucleotide distribution of the binding region, by subsetting the consensus profile from [Step 1](#Step1). 

```{r}
## Get the binding region of the first oligo in the selection above (first row): 
bindingRegion <- myConsensusProfile[
  myConsensusProfile$position >= oligoSelection[1, ]$start & 
    myConsensusProfile$position <= oligoSelection[1, ]$end,
  ]
```

It can be plotted in forward direction: 

```{r}
plotData(bindingRegion, type = "nucleotide")
```

Or as reverse complement, by specifying `rc = TRUE`: 

```{r}
plotData(bindingRegion, type = "nucleotide", rc = TRUE)
```

**Design with modified settings**

In the next example, I show how to modify some of the design constraints: 

```{r}
myOligosModified <- oligos(myConsensusProfile, 
                           maxDegeneracyPrimer = 32, 
                           tmRangePrimer = c(50, 70),
                           lengthPrimer = 16:24, 
                           maxDegeneracyProbe = 1)
```

There are now more primer candidates (due to relaxed constraints) and less probe candidates (due to tighter constraints):

```{r, fig.align="center", fig.width=12, fig.height=8}
plotData(myOligosModified)
```

**Select a region of interest**

Below, I show how to select a particular region of interest of the genome (position 1000 to 4000):

```{r}
roi <- myConsensusProfile[
  myConsensusProfile$position >= 1000 & myConsensusProfile$position <= 4000, 
  ]
```

**Design using the mixed strategy**

I now design mixed primers for the region of interest above, and select to not design probes:

```{r, fig.align="center", fig.width=12, fig.height=8}
myMixedPrimers <- oligos(roi, 
                         designStrategyPrimer = "mixed", 
                         probe = FALSE)

plotData(myMixedPrimers)
```

Results (first ten rows):

```{r, echo=FALSE}
myMixedPrimers[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

Importantly, for mixed primers, identity refers to the average identity within the 5' consensus part of the primer binding region and coverage refers to the average coverage of 3' degenerate part of the primer. For ambiguous oligos, both of these values are calculated for the entire oligo. For a detailed explanation of identity and coverage, see [Step 1](#Step1).

**Masking**

For sequencing applications such as genotyping, there is often an interest in amplifying a specific region of the genome. In such cases, the primer dataset can be masked to not contain forward primers after the start position and to not contain reverse primers after the end position of the intended amplicon.

Below, I show how to create a subset of `myMixedPrimers`, where all primers between position 2000-3000 are removed: 

```{r}
myMixedPrimersMasked <- myMixedPrimers[
  (myMixedPrimers$fwd & myMixedPrimers$end < 2000) |
    (myMixedPrimers$rev & myMixedPrimers$start > 3000),
]

plotData(myMixedPrimersMasked)
```

### Step 3: `assays` {#Step3}

The next step is to find pairs of forward and reverse primers, and eventually, combine them with probes. Probes will be added if the input dataset contains probes. 

`assays()` has two arguments:   

* `x`: the oligo dataset from [Step 2](#Step2)
* `lengthRange`: amplicon length range, defaults to `c(65, 120)`

**[Här kan man med lätthet matcha primerpar på deras tm, men detta är inte helt optimalt enligt santalucia 2004, dock kanske det ar praktiskt gångbart ändå?]**

An error message will return if no assays are found.

Below, I show how to design assays using default settings using the dataset `myOligos` from [Step 2](#Step2): 

```{r}
myAssays <- assays(myOligos)  
```

Output (first ten rows): 

```{r, echo=FALSE}
myAssays[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The output contains many columns, but it can be viewed by using `View(as.data.frame(myAssays))`, if you are working in RStudio. 

Again, the results can be visualized using `plotData()`: 

```{r, fig.width=12, fig.height=6}
plotData(myAssays)
```

All candidate assays are located within a conserved stretch of ~70 bases. This is also the target region for the most frequently used RT-qPCR assay for detection of HEV, developed by Jothikumar and colleagues [@jothikumar2006broadly].

There are now over 1000 assays, but one way of reducing the amount is to subset the output dataset to only contain assays with the best total oligo scores (see the score variable in the table above). The best possible score is 0 and the worst possible score is 24 for an assay with only primers and 36 for an assay with probe (the maximum possible score for each oligo is 12; see [Step 2](#Step2) for more information).

```{r, fig.width=12, fig.height=6}
## Get the minimum score from myAssays
bestAssayScore <- min(myAssays$score)
bestAssayScore

## Make a subset that only contains the assays with the best scor 
myAssaySelection <- myAssays[myAssays$score == bestAssayScore, ]

## Plot these assays 
plotData(myAssaySelection)
```

**Design with modified settings**

To illustrate assay design with modified settings, I use the masked dataset from [Step 2](#Step2) (`masked`), where I designed primers to cover position 2000-3000: 

```{r}
myMixedAssays  <- assays(myMixedPrimersMasked, lengthRange = c(1000, 2000))

plotData(myMixedAssays)
```

## Further handling of the data 

### Check match 

`checkMatch()` checks how well the generated oligos or assays match to the input alignment. The function has two arguments: 

* `x`: an oligo or assay dataset from [Step 2](#Step2) or [3](#Step3)
* `target`: the target alignment used as input in [Step 1](#Step1)

The output gives information of the proportion of target sequences that matches perfectly as well as with 1, 2, 3 or 4 or more mismatches to the oligo, within the intended oligo binding region (i.e., on target match). It also reports the proportion of target sequences that matches to the oligo with no more than 4 mismatches within *all other regions* in the alignment (off target match). But note that the output does not say anything about the type, position or severity of the mismatches.

Below, I show how to use `checkMatch()` for both oligos and assays. The function is rather slow, especially if there are many target sequences, so a good idea could be to select only a few oligo or assay candidates to investigate. 

**Oligos**

```{r}
oligoSelectionMatch <- checkMatch(oligoSelection, target = myAlignment)
```

```{r, echo=FALSE}
oligoSelectionMatch[1:10, ] %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The output (on target matches) can be visualized using `plotData()`: 

```{r, fig.width=12, fig.height=12}
plotData(oligoSelectionMatch)
```

**Assays** 

```{r}
assaySelection <- myAssays[1:3, ]

assaySelectionMatch <- checkMatch(assaySelection, target = myAlignment)
```

```{r, echo=FALSE}
assaySelectionMatch %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

The output (on target matches) can be visualized using `plotData()`: 

```{r, fig.width=12, fig.height=12}
#plotData(assaySelectionMatch)
```

It is also possible to add the match information to the input oligo or assay by using `cbind()`:

```{r}
toAdd <- assaySelectionMatch[
  #, !(grepl("iupacSequence") %in% names(assaySelectionMatch))
  ]

assaySelection <- cbind(assaySelection, toAdd)
```

The columns named iupacSequence in `assaySelectionMatch` can be removed when pasting the two objects together, to avoid duplication.

```{r, echo=FALSE}
assaySelection %>%
  kbl(., digits = 2) %>%
  kable_material(c("striped", "hover"), position = "right") %>%
  scroll_box(width = "650px", height = "300px")
```

### Oligo and assay binding regions 

Oligo and assay binding region(s) can be inspected in more detail by using the consensus profile from [Step 1](#Step1). As an example, I select to take a closer look at the first assay in `myAssaySelection` from [Step 3](#Step3).

The first step is to retrieve the start and end position of the assay, as follows:

```{r}
from <- myAssaySelection[1, ]$start
to <- myAssaySelection[1, ]$end
```

It is now possible to indicate the amplicon region, using the `highlight` argument in `plotData()`:

```{r fig 3, fig.width=12, fig.height=6}
plotData(myConsensusProfile, highlight = c(from, to))
```

To get a more detailed view, we can make a subset of the consensus profile to only contain the amplicon region: 

```{r}
myAssayRegion <- myConsensusProfile[
  myConsensusProfile$position >= from & 
    myConsensusProfile$position <= to, 
] 
```

And plot it:

```{r, fig.width=12, fig.height=6, fig.align="center"}
plotData(myAssayRegion)
plotData(myAssayRegion, type = "nucleotide")
```

The consensus amplicon sequence can be obtained by: 

```{r}
paste(myAssayRegion$iupac, collapse = "")
```

## Export to file

Before proceeding to wet lab evaluation, it is highly recommended to evaluate the final primer and probe candidates for 1) the potential to form primer dimers and hairpin structures, and 2), the potential to (not) cross react with non-targets. 

These tasks are best performed by other software. Below, I show how to export the results to file so that they can be analyzed by other tools.  

**Result tables**

Result tables can be readily saved to .txt or .csv-files, for instance: 

```r
write.csv(myAssays, file = "myAssays.csv", quote = FALSE, row.names = FALSE) 
write.table(myAssays, file = "myAssays.txt", quote = FALSE, row.names = FALSE) 
```

**Oligos and assays to fasta format**

It is also possible to export the oligo sequences in fasta-format. `convertToDNAStringSet()` is used for converting oligos or assays to a `Biostrings::DNAStringSet`-object. 

`convertToDNAStringSet()` has three arguments:   

* `x`: an oligo or assay dataset (i.e., an output from [Step 2](#Step2) or [3](#Step3))
* `asRc`: if oligos should be written as reverse complements or not (for oligos), and if reverse primers and minus sense probes should be written as reverse complements or not (for assays). Defaults to `FALSE`
* `asIUPAC`: if the oligos should be presented in IUPAC-format or not. Defaults to `TRUE`. If `FALSE`, all sequence variants of each oligo will be presented instead 

Below, I convert the two first oligos in `myOligos` from [Step 2](#Step2):

```{r}
convertToDNAStringSet(myOligos[1:2, ])
```

And the first assay in `myAssays` from [Step 2](#Step2):

```{r}
convertToDNAStringSet(myAssays[1, ], asRc = TRUE, asIUPAC = FALSE)
```

The sequences can then be saved as fasta format, for example: 

```r
toFile <- oligosToDNAStringSet(myOligos)
Biostrings::writeXStringSet(toFile, file = "myOligos.txt")

```

# Summary 

The design process is summarized below. 

```r
library(rprimer)

## Enter the filepath to an alignment with target sequences of interest 
filepath <- system.file("extdata", "example_alignment.txt", package = "rprimer")

## Import the alignment 
myAlignment <- Biostrings::readDNAMultipleAlignment(filepath, format = "fasta") 

## Design primers, probes and assays (modify settings if needed) 
myConsensusProfile <- consensusProfile(myAlignment, ambiguityThreshold = 0.05)
myOligos <- oligos(myConsensusProfile)
myAssays <- assays(myOligos)

## Visualize the results 
plotData(myConsensusProfile)
plotData(myOligos)
plotData(myAssays)

## Show tables (in RStudio)
View(as.data.frame(myConsensusProfile))
View(as.data.frame(myOligos))
View(as.data.frame(myAssays))
```

# Classes and example data

The "rprimer" classes (`RprimerProfile`, `RprimerOligo`, `RprimerAssay`, `RprimerMatchOligo` and `RprimerMatchAssay`) are extensions of the `DataFrame` class from S4Vectors [@PagesS4], and behave in a similar way as traditional data frames, with methods for `[`, `$`, `nrow`, `ncol`, `head`, `tail`, `rbind`, `cbind` etc. They can be coerced to traditional data frames by using `as.data.frame()`. 

Example datasets of each class are provided with the package, and are loaded by: 

```{r, warning=FALSE}
data("exampleRprimerProfile")
data("exampleRprimerOligo")
data("exampleRprimerAssay")
data("exampleRprimerMatchOligo")
data("exampleRprimerMatchAssay")
```

To provide reproducible examples, I have also included an alignment of class `Biostrings::DNAMultipleAlignment`. It is loaded by `data("exampleRprimerAlignment")`.

# Table values  

Tables used for determination of complement bases, IUPAC consensus character codes, degeneracy and nearest neighbors can be found by typing:

* `rprimer:::lookup$complement`
* `rprimer:::lookup$iupac`, `rprimer:::lookup$degenerates`, 
* `rprimer:::lookup$degeneracy` and 
* `rprimer:::lookup$nn`, respectively. 

# Source code 

The source code is available at https://github.com/sofpn/rprimer. 

# Citation

To cite this package, please use: `citation("rprimer")`.

# Session info 

The otput from `sessionInfo()` when generating this document is shown below. 

```{r}
sessionInfo()
```

# References 
