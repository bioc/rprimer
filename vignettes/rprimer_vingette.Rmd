---
title: "Getting started with rprimer"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Getting started with rprimer}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(rprimer)
library(magrittr)
```

## Introduction 

rprimer is designed to automate primer, probe and PCR assay design as much as possible. 

There are a multitude of factors to take into account when designing primers, probes and PCR-assays, for instance:  

* GC content
* Melting temperature
* Sequence conservation 
* Sequence complexity ... 

## Installation

Install rprimer by calling:

```{r}

# if (!requireNamespace("devtools", quietly = TRUE)) {
#    install.packages("devtools")
# }
# devtools::install_github("sofpn/rprimer")

# library(rprimer)
```

## Quick start

The primer, probe and assay design workflow is summarized below. 

```{r}
# Step 1: Import alignment 
my_alignment <- "example_alignment.txt" %>% 
  read_fasta_alignment %>%
  remove_gaps(., threshold = 0.5)  %>% 
  select_roi(., from = 4000, to = 6000) 

# Step 2: Get the sequence profile 
my_sequence_profile <- sequence_profile(my_alignment)

# Step 3: Get sequence properties 
my_sequence_properties <- sequence_properties(
  my_sequence_profile, iupac_threshold = 0.05 
) 

# Step 4: Get primers
my_primers <- get_oligos(
  my_sequence_properties, 
  target = my_alignment,
  max_gap_frequency = 0.05, 
  length = 18:22,
  max_degenerates = 1,
  max_degeneracy = 2, 
  avoid_3end_ta = TRUE, 
  avoid_3end_runs = TRUE,
  avoid_gc_rich_3end = TRUE,
  avoid_5end_g = FALSE,
  gc_range = c(0.45, 0.56),
  tm_range = c(55, 70), 
  conc_oligo = 5e-07, 
  conc_na = 0.05   
)

# Step 5: Get assays 
my_assays <- get_assays(my_primers, length = 65:75, max_tm_difference = 1.5) 
 
# Step 6: Get probes 
my_probes <- get_oligos(
  my_sequence_properties,
  target = my_alignment,
  max_gap_frequency = 0.05,
  length = 18:24,
  max_degenerates = 1,
  max_degeneracy = 2,
  avoid_3end_ta = FALSE,
  avoid_3end_runs = FALSE,
  avoid_gc_rich_3end = FALSE,
  avoid_5end_g = TRUE,
  gc_range = c(0.45, 0.56),
  tm_range = c(55, 70),
  conc_oligo = 2.5e-07, 
  conc_na = 0.05
)

# Step 7: Add probes to assays
my_assays <- add_probes(my_assays, my_probes, tm_difference = c(-1, 5))  

# Step 8: Save the data (if you want to)
# rp_save(my_alignment, filename = "my_alignment")
# rp_save(my_sequence_properties, filename = "my_sequence_properties")
# rp_save(my_assays, filename = "my_assays")

# Step 9: Generate a report

# You can either select one assay and generate a report...
selected_assay <- my_assays[1, ]

# write_report(
#  filename = "my_assay_report",
#  selected_assay,
#  my_sequence_profile,
#  my_sequence_properties,
#  comment = "my new hepatitis E virus assay :)"
# )
```

## Details  

Below, I demonstrate how to use rprimer by designing a real-time RT-PCR assay for detection of hepatitis E virus (HEV).

### Step 1: Import alignment 
Prepare a .txt-file with an alignment of the sequences of interest (in fasta-format), and import it using `read_fasta_alignment()`. In this example, I use an alignment with 621 HEV sequences that I have collected from GenBank. 

```{r}
my_alignment <- "example_alignment.txt" %>% 
  read_fasta_alignment
```

From here, it is possible to either proceed directly to Step 2, or to process the alignment using `remove_gaps()` and/or `select_roi()`:

```{r}
my_alignment <- remove_gaps(my_alignment, threshold = 0.5)  %>%
  select_roi(., from = 4000, to = 6000)
```

* `remove_gaps()` removes positions with a gap proportion higher than the stated `threshold` (the default is 0.5, i.e. 50 %). 

* `select_roi()` selects a region of interest (ROI) within the alignment. 

The output can be visualized with `rp_plot()`, where each sequence is represented as a horizontal line. 

```{r, fig.width=6, fig.height=6, fig.align='center'}
# For brevity, I decided to only include the first 50 sequences in the figure
#rp_plot(my_alignment[1:50]) #fix problem here w\ S3 class subsetting
```

### Step 2: Get the sequence profile 
`sequence_profile()` takes an alignment as input and returns a matrix with the proportion of each nucleotide at each position in the alignment. 

```{r}
my_sequence_profile <- sequence_profile(my_alignment)

# The first 6 positions of the sequence profile
my_sequence_profile[, 1:6]
```

The sequence profile can be visualized with `rp_plot()`. A specific region can be selected with `from` and `to`. The `rc` option regulates whether the sequence should be displayed as a reverse complement or not (the default is `FALSE`).

```{r, fig.width=6, fig.height=6, fig.align='center'}
# The first 30 positions of the sequence profile  
rp_plot(my_sequence_profile, from = 1, to = 30, rc = FALSE) 
```

### Step 3: Get sequence properties 
`sequence_properties()` takes a sequence profile as input and returns a tibble (a data frame) with the following sequence properties: 

* *Majority*. The majority consensus sequence (the most frequently occurring nucleotide). 

* *Iupac*. The IUPAC-consensus sequence, which includes wobble bases according to the IUPAC-nomenclature. All nucleotides with a proportion higher than or equal to `iupac_threshold` will be included in the IUPAC-consensus sequence.  

* *Gaps*. The proportion of gaps.  

* *Identity*. The proportion of the most frequently occurring base.

* *Entropy*. The Shannon entropy, which is a measurement of variability. A value of zero indicate no variability and a high value indicate high variability. 

```{r}
my_sequence_properties <- sequence_properties(
  my_sequence_profile, iupac_threshold = 0.05
)

str(my_sequence_properties)
```

Again, the output can be visualised with `rp_plot()`. Here, vertical bars represent the value at each position. The black bars in the two uppermost figures represent values of 1 and 0, respectively (i.e. positions with complete conservation). The horizontal lines represent centered running averages. 

```{r,fig.width=6, fig.height=6, fig.align='center'}
rp_plot(my_sequence_properties)
```

### Step 4: Find primers 
`get_oligos()` takes sequence properties as input and searches for oligos that fulfill the following criteria: 

* `max_gap_frequency` Maximum allowed gap frequency. The default is 0.1, which means that only positions with a  gap frequency of <=0.1 will be considered.

* `length` Oligo length. The default is 18-22.

* `max_degenerates` The maximum number of degenerate positions in each oligo. The default is 2. 

* `max_degeneracy` The maximum number of degenerate variants of each oligo. The default is 4. 

* `avoid_3end_ta` If oligos with a T or an A at the 3' end should be avoided (recommended for primers to enhance specificity). The default is `TRUE`.

* `avoid_3end_runs` If oligos with more than two runs of the same nucleotide at the 3' end should be excluded (recommended for primers to avoid mispriming). The default is `TRUE`.

* `avoid_gc_rich_3end` If oligos with more than three G or C within the last five bases of the 3' end should be excluded (recommended for primers to avoid mispriming). The default is `TRUE`.

* `avoid_5end_g` If oligos with a G at the 5' end should be avoided (recommended for probes). The default is `FALSE`.

* `gc_range` GC-content-range (proportion, not %). The default is 0.45-0.55. 

* `tm_range` melting temperature (Tm) range. The default is 48-65 degrees Celcius. Tm is calculated using the nearest-neigbour method. See `?get_oligos` for a detailed description and references. 

* `conc_oligo` Oligo concentration (for Tm calculation). The default is 5e-07 M (500 nM).

* `conc_na` Sodium ion concentration (for Tm calculation). The default is 0.05 M (50 mM).

In addition, `get_oligos()` avoids oligos:

* With more than than three consecutive runs of the same dinucleotide (e.g. "TATATATA")

* With more than four consecutive runs of the same nucleotide (e.g. "AAAAA")

* That are duplicated (to prevent binding at several places on the genome)

```{r}
my_primers <- get_oligos(
  my_sequence_properties,
  target = my_alignment,
  max_gap_frequency = 0.01,
  length = 18:22,
  max_degenerates = 1,
  max_degeneracy = 2,
  avoid_3end_ta = TRUE,
  avoid_3end_runs = TRUE,
  avoid_gc_rich_3end = TRUE, 
  avoid_5end_g = FALSE,
  gc_range = c(0.45, 0.56),
  tm_range = c(55, 65),
  conc_oligo = 5e-07, 
  conc_na = 0.05
)

```

Candidate oligos are displayed in a tibble. Oligo sequences are displayed in both majority and IUPAC format, and as reverse complements (rc). `NA` means that the oligo was excluded due to e.g. a terminal A or T (if `avoid_3end_ta = TRUE`). An error message will return if no oligos are found. 

I found 52 primers in my example. Most of them are located around position 1300, which is the most conserved region in my ROI. I only allowed one degenerate base in each primer, and no more than two variants of each primer. More primers can be found by increasing `max_degenerates` and `max_degeneracy`, or by increasing the `iupac_threshold` in the `sequence_properties()` function. 

**present match matrices separately**

```{r}
str(my_primers[, -ncol(my_primers)])
```

### Step 5: Get assays 
`get_assays()` finds pairs of forward and reverse primers that fulfil the following criteria:  

* `length` Amplicon length. The default is 65-120.

* `max_tm_difference` The maximum Tm difference between the two primers (absolute value, in C). The default is 1. Note that Tm-difference is calculated from the majority oligos, and may thus be misleading for degenerate (IUPAC) oligos.

```{r}
my_assays <- get_assays(my_primers, length = 65:120, max_tm_difference = 1.5)
```

Candidate assays are displayed in a tibble (see below). An error message will return if no assays are found. Three different combinations of forward and reverse primer were found in this example. `total_degeneracy` is the sum of the number of variants of the forward primer and reverse primer. 

**describe perfect match matrices, and pm percentages**
**present less ugly output**

```{r}
str(my_assays[ , -ncol(my_assays)])
```

### Step 6: Add probes 
Probes can be generated with `get_oligos()`, and added to assays with `add_probes()`. 

Here, `tm_difference` is the acceptable difference in Tm between the primers and probe. It is calculated by subtracting the Tm of the probe with the average Tm of the primer pair. Hence, a negative Tm-difference means that the Tm of the probe is lower than the average Tm of the primer pair. Note that the Tm-difference is calculated from the majority oligos, and may thus be misleading for degenerate (IUPAC) oligos.

Assays are displayed in a tibble (see below). An error message will return if no assays are found.   

```{r}
my_probes <- get_oligos(
  my_sequence_properties,
  target = my_alignment,
  max_gap_frequency = 0.01,
  length = 18:24,
  max_degenerates = 1,
  max_degeneracy = 2,
  avoid_3end_ta = FALSE,
  avoid_3end_runs = FALSE,
  avoid_5end_g = TRUE,
  gc_range = c(0.45, 0.56),
  tm_range = c(55, 70),
  conc_oligo = 2.5e-07, 
  conc_na = 0.05
)

my_assays <- add_probes(my_assays, my_probes, tm_difference = c(0, 10))

str(my_assays[ , -ncol(my_assays)])

```

### Step 8: Save results 
Alignments, sequence properties, primer, probe and assay candidates can be exported using `rp_save()`. Objects of class 'rprimer_alignment' will be saved as .txt-files, whereas objects of class 'rprimer_sequence_properties', 'rprimer_oligo' and 'rprimer_assay' will be saved as .csv-files.

```{r}
# rp_save(my_alignment, filename = "my_alignment")
# rp_save(my_sequence_properties, filename = "my_sequence_properties")
# rp_save(my_assays, filename = "my_assays")
```

### Step 9: Select an assay and generate a report 
For each assay, a report can be generated by calling `write_report()`. You can either select one assay and generate a report, or generate reports for all assays (see code example below). 

Let's say that I want the assay that has the highest perfect match score. 

...... etc....

G repeats within the amplicon region can prevent strand dissociation and thus reduce amplification efficiency (ref: S. Bustin, J. Hugget 2017).

```{r}
my_assays <- dplyr::arrange(my_assays, pm_majority_all)

selected_assay <- my_assays[1, ] # Select an assay 

# write_report(
#  filename = "my_assay",
#  selected_assay,
#  my_sequence_profile,
#  my_sequence_properties,
#  comment = "my new hepatitis E virus assay :)" 
# )
```

It is also possible to generate reports for all assays, for instance:  

```{r}
# purrr::walk(seq_len(nrow(my_assays)), function(i) {
#  write_report(
#    filename = paste0("my_assay_report_", i),
#    my_assays[i, ],
#    my_sequence_profile,
#    my_sequence_properties,
#   comment = paste("my new hepatitis E virus assay, number", i)
#  )
#})
```

The assay report contain more detailed information about the assay, and the output is presented in html format, as in the example below. Note that RMarkdown and kablEextra must be installed for this function to work.   
<br><br>
![](design_report1.png)
![](design_report2.png)
![](design_report3.png)
